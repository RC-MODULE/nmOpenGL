Описание и алгоритмы работы интерфейсных графических функций текстурирования
----------------------------------------------------------------------------

Данный раздел содержит описание и алгоритмы интерфейсных функций текстурирования nmOpenGL, входящих в состав \"Библиотеки графических функций текстурирования\".

Функции из состава \"Библиотеки графических функций текстурирования\" являются интерфейсными функциями nmOpenGL, выполняются на процессорном ядре NMPU0, и их алгоритмы практически не зависят от того, на каком из процессорных ядер конвейера выполняется непосредственное закрашивание пикселей в процессе текстурирования. В данном разделе представлены универсальные алгоритмы интерфейсных функций текстурирования, учитывающие возможность реализации текстурирования как на процессорном ядре NMPU0, так и на процессорном ядре NMPU1. Шаги алгоритма, выделенные курсивом, используются только в случае реализации функций закрашивания пикселей на процессорном ядре NMPU1. Для случая реализации функций закрашивания текстурирования на NMPU0, описанного в данном разделе, шаги алгоритма, выделенные курсивом, не выполняются и исключаются из реализации интерфейсных функций текстурирования.

### Функция nmglTexImage2D

#### Прототип функции

void nmglTexImage2D (NMGLenum target, NMGLint level, NMGLint internalformat, NMGLsizei width, NMGLsizei height, NMGLint border, NMGLenum format, NMGLenum type, const void \*pixels);

#### Назначение

Функция обеспечивает загрузку текстурного изображения в активный текстурный объект.

#### Входные данные

**NMGLenum target -** определяет тип текстуры и должен иметь значение NMGL_TEXTURE_2D.

**NMGLint level -** определяет mipmap уровень, для которого осуществляется загрузка текстурного изображения. Значения данного аргумента должны лежать в диапазоне от 0 до NMGL_MAX_MIPMAP_LVL, где NMGL_MAX_MIPMAP_LVL -- максимальный уровень mipmap, поддерживаемый реализацией для целевой архитектуры.

**NMGLint internalformat** - определяет количество цветовых компонент текселя, и может принимать значения: NMGL_RGBA (4 компоненты), NMGL_RGB (3 компоненты), NMGL_ALPHA (1 компонента), NMGL_LUMINANCE (1 компонента), NMGL_LUMINANCE_ALPHA (две компоненты) и NMGL_COLOR_INDEX8_EXT (1 компонента). Каждая компонента должна иметь тип NMGLubyte.

**NMGLsizei width** - определяет соответственно длину строки (ширину) текстурного изображения в текселях.

**NMGLsizei height** - определяет соответственно длину столбца (высоту) текстурного изображения в текселях.

**NMGLint border** - определяет ширину границы текстуры. Должен иметь значение 0.

**NMGLenum format** - определяет формат данных текселя. Если значение аргумента **internalformat** равно NMGL_COLOR_INDEX8_EXT, то значение аргумента **format** должно быть равно NMGL_COLOR_INDEX. В противном случае значение аргумента **format** должно совпадать со значением аргумента **internalformat.**

**NMGLenum type** - определяет тип данных текселя. Должен иметь значение NMGL_UNSIGNED_BYTE.

**const void \*pixels** - указатель на текстурное изображение, хранящееся в памяти.

#### Выходные данные

Отсутствуют

#### Возвращаемое значение

Отсутствует

#### Алгоритм

Функция текстурирования nmglTexImage2D работает в соответствии со следующим алгоритмом:

1.  Получить указатель на объект контекста.

2.  Осуществить проверку значений аргументов:

    1.  Если значение аргумента target не равно NMGL_TEXTURE_2D, то записать в поле ошибки контекста значение NMGL_INVALID_ENUM и завершить работу.

    2.  Если значени аргумента level меньше 0 или больше NMGL_MAX_MIPMAP_LVL, то записать в поле ошибки контекста значение NMGL_INVALID_VALUE и завершить работу.

    3.  Если значени аргумента border не равно 0, то записать в поле ошибки контекста значение NMGL_INVALID_VALUE и завершить работу.

    4.  Если значени аргумента type не равно NMGL_UNSIGNED_BYTE, то записать в поле ошибки контекста значение NMGL_INVALID\_ ENUM и завершить работу.

    5.  Если хотя бы одно из значений аргументов width и height меньше нуля, больше NMGL_MAX_TEX_SIDE (параметр, определяемый реализацией, и характеризующий размер строки или столбца текстурного изображения уровня 0 при наличии NMGL_MAX_MIPMAP_LVL mipmap уровней), или не является стеенью числа 2, то записать в поле ошибки контекста значение NMGL_INVALID_VALUE и завершить работу.

    6.  Если значение аргумента internalformat не равно NMGL_COLOR_INDEX8_EXT и значение аргумента format не равно NMGL_COLOR_INDEX:

        1.  Если значение аргумента internalformat не совпадает со значением аргумента format, то записать в поле ошибки контекста значение NMGL_INVALID_VALUE и завершить работу.

        2.  Если значение аргумента internalformat не совпадает ни с одним из значений из следующего списка (NMGL_RGBA, NMGL_RGB, NMGL_LUMINANCE, NMGL_ALPHA, NMGL_LUMINANCE_ALPHA), то записать в поле ошибки контекста значение NMGL_INVALID_VALUE и завершить работу.

3.  Осуществить проверку факта первичного вызова функции nmglTexImage2D для данного текстурного объекта (путём анализа соответствующего поля текстурного объекта -- поля imageIsSet). Если текущий вызов функции -- первый (imageIsSet=0), то перейти к пункту 10. В противном случае перейти к пункту 4.

4.  Если включено mipmap текстурирование (значение поля texMinFilter текстурного объекта одно из NMGL_NEAREST_MIPMAP_NEAREST, NMGL_NEAREST_MIPMAP_LINEAR, NMGL_LINEAR_MIPMAP_NEAREST, NMGL\_ LINEAR \_MIPMAP\_ LINEAR), то перейти к пункту 5. В противном случае перейти к пункту 8.

5.  Если значения аргумента internalformat не совпадает с одноимённым полем текстурного изображения уровня level активного текстурного объекта, то записать в поле ошибки контекста значение NMGL_INVALID_OPERATION и завершить работу.

6.  Если значения аргументов width и height не совпадают с одноимёнными полями текстурного изображения уровня level активного текстурного объекта, то записать в поле ошибки контекста значение NMGL_INVALID_OPERATION и завершить работу.

7.  Осуществить переход к пункту 13

8.  Если значение аргумента level не равно 0, то записать в поле ошибки контекста значение NMGL_INVALID_OPERATION и завершить работу.

9.  Осуществить переход к пункту 5.

10. Если значение аргумента level не равно 0, то записать в поле ошибки контекста значение NMGL_INVALID_OPERATION и завершить работу.

11. Проинициализировать указатели на память для каждого mipmap уровня активного текстурного объекта.

    1.  Присвоить переменной cursize значение произведения NMGL_MAX_TEX_SIDE^2^\*UBYTES_PER_TEXEL, где NMGL_MAX_TEX_SIDE -- значение стороны текстурного изображения уровня 0 в текселях для изображения, имеющего NMGL_MAX_MIPMAP_LVL mipmap уровней. UBYTES_PER_TEXEL -- количество элементов типа NMGLubyte, приходящихся на 1 тексель формата NMGL_RGBA.

    2.  Присвоить указателю на уровень 0 текстурного изображения активного текстурного объекта значение mipmap+name\*MIPMAP_OBJ_SIZE, где

> mipmap -- адрес начала памяти текстурных объектов;
>
> name -- индекс текстурного объекта
>
> MIPMAP_OBJ_SIZE -- количество элементов типа NMGLubyte, необходимых для хранения изображения, имеющего NMGL_MAX_MIPMAP_LVL mipmap уровней (текстурного изображения максимального размера).

3.  Для всех mipmap уровней последовательно от 1 до NMGL_MAX_MIPMAP_LVL делать:

    1.  P~i~ = P~i-1~+cursize;

    2.  *Послать команду синхронизации контекстов NMC1_SET_MIPMAP_LVL_POINTER на второй процессор nmc(nm1), передав в качестве аргументов значения texture, level и P~i~.*

    3.  cursize=cursize/4;

```{=html}
<!-- -->
```
12. Для всех mipmap уровней последовательно от 0 до NMGL_MAX_MIPMAP_LVL включительно:

    1.  Полю internalformat установить значение аргумента internalformat;

    2.  Если рассматривается нулевой уровень, то:

        1.  Полям width и height текстурного изображения уровня level активного текстурного объекта присвоить значения одноимённых аргументов

        2.  *Послать команду синхронизации NMC1_SET_WHF на второй процессор nmc(nm1), передав в качестве аргументов значение поля name активного текстурного объекта, номер текущего уровня, значения аргументов width, height и internalformat.*

        3.  Перейти к пункту 13.

    3.  Если значение поля width нулевого уровня, сдвинутое на lvl разрядов вправо, больше 0, то присвоить значению поля width текущего уровня значение поля width нулевого уровня, сдвинутое на lvl разрядов вправо. Здесь lvl -- номер текущего уровня. В противном случае присвоить значению поля width текущего уровня значение 1.

    4.  Повторить выполнение дествий пункта 12.3 для поля height текущего уровня.

13. Скопировать текстурное изображение, доступное по указателю pixels, в активный текстурный объект.

    1.  Определить размер текселя в элементах типа NMGLubyte в зависимости от поля internalformat.

    2.  Если указатель на текстурное изображение равен NULL вывести сообщение об ошибке и завершить работу.

    3.  Обнулить значение переменной padLength, характеризующей количество элементов типа NMGLubyte, использующихся для выравнивания каждой строки текстурного изображения.

    4.  Если значение поля unpackAlignment контекста равно 1, то последовательно скопировать width\* height\*size элементов типа NMGLubyte из текстурного изображения в активный текстурный объект и перейти к пункту 14.

14. Установить значение поля imageIsSet в единицу.

*При получении команды NMC1_SET_MIPMAP_LVL_POINTER процессор nm1должен осуществить следующие действия:*

1.  *Полю pixels тектурного изображения уровня level (получен вместе с командой) массива текстурных изображений texImages2D тектурного объекта с индексом texture (получен вместе с командой) массива текстурных объектов контекста присвоить значение P~i~ (переданное с командой).*

### Функция nmglTexSubImage2D

#### Прототип функции

void nmglTexSubImage2D (NMGLenum target, NMGLint level, NMGLint xoffset, NMGLint yoffset, NMGLsizei width, NMGLsizei height, NMGLenum format, NMGLenum type, const void \*pixels);

#### Назначение

Функция осуществляет запись фрагмента текстурного ищображения в активный текстурный объект.

#### Входные данные

**NMGLenum target** - определяет тип текстуры и должен иметь значение NMGL_TEXTURE_2D.

**NMGLint level** - определяет mipmap уровень, для которого осуществляется загрузка фрагмента текстурного изображения. Значения данного аргумента должны лежать в диапазоне от 0 до NMGL_MAX_MIPMAP_LVL, где NMGL_MAX_MIPMAP_LVL -- максимальный уровень mipmap, поддерживаемый реализацией для целевой архитектуры.

**NMGLint xoffset** - определяет смещение в текселях по оси x левого нижнего угла фрагмента текстурного изображения внутри текстурного изображения, куда осуществляется запись.

**NMGLint yoffset** - определяет смещение в текселях по оси y левого нижнего угла фрагмента текстурного изображения внутри текстурного изображения, куда осуществляется запись.

**NMGLsizei width** - определяет ширину фрагмента текстурного изображения в текселях.

**NMGLsizei height** - определяет высоту фрагмента текстурного изображения в текселях.

**NMGLenum format** - определяет формат данных текселя. Возможные значения: NMGL_RGBA, NMGL_RGB, NMGL_ALPHA, NMGL_LUMINANCE и NMGL_LUMINANCE_ALPHA.

**NMGLenum type** - определяет тип данных текселя. Должен иметь значение NMGL_UNSIGNED_BYTE.

**const void \*pixels** - указатель на фрагмент текстурного изображения в памяти.

#### Выходные данные

Отсутствуют

#### Возвращаемое значение

Отсутствует

#### Алгоритм 

Алгоритм работы функции состоит в следующем:

1\. Получить указатель на объект контекста.

2\. На основе значения поля internaformat текстурного изображения mipmap уровня level активного текстурного объекта определить количество элементов типа NMGLubyte, содержащихся в одном текселе.

3\. Осуществить проверку значений аргументов:

3.1. Если значение аргумента target не равно NMGL_TEXTURE_2D, то записать в поле ошибки контекста значение NMGL_INVALID_ENUM и завершить работу

3.2. Если значение аргумента level \<0 или больше NMGL_MAX_MIPMAP_LVL, то записать в поле ошибки контекста значение NMGL_INVALID_VALUE и завершить работу

3.3. Если значени аргумента type не равно NMGL_UNSIGNED_BYTE, то записать в поле ошибки контекста значение NMGL_INVALID\_ ENUM и завершить работу.

3.4. Если хотя бы одно из значений аргументов width и height меньше нуля, то записать в поле ошибки контекста значение NMGL_INVALID_VALUE и завершить работу.

3.5. Если хотя бы одно из значений аргументов xoffset и yoffset меньше нуля, или если хотя бы одно из значений выражений (xoffset+width) и (yoffset+height) больше значения поля width и height соответственно (поля текстурного изображения уровня level активного текстурного объекта), то записать в поле ошибки контекста значение NMGL_INVALID_VALUE и завершить работу.

3.6. Если значение аргумента format не равно значению поля internalformat текстурного изображения уровня level активного текстурного объекта, то записать в поле ошибки контекста значение NMGL_INVALID_OPERATION и завершить работу.

4\. Определить размер строки текстурного изображения уровня level активного текстурного объекта в элементах типа NMGLubyte и записать в переменную line.

5\. Определить количество элементов типа NGLubyte, использующихся для выравнивания в каждой строке входного текстурного изображения (paddings) на основе значения поля unpackAlignment контекста (unpackAlignment), количества элементов типа NMGLubyte в одном текселе (tSize) и значения ширины входного текстурного изображения в текселях (width) по формуле:

paddings= ((width\*tSize) % unpackAlignment == 0) ? 0 : (unpackAlignment - (width\*tSize) % unpackAlignment)

6\. Определить положение стартового элемента типа NMGLubyte (xstart) для вставки входного текстурного изображения относительно начала текстурного изображения уровня level активного текстурного объекта:

xstart= (yoffset \* line + xoffset \* tSize)

7\. Для каждой i-ой строки от 0 до height-1:

7.1. Для каждого j-го элемента типа NMGLubyte от 0 до width\*tSize-1

7.1.1. Элементу типа NMGLubyte, доступному по указателю (NMGLubyte\*)p+xstart+i\*line+j) присвоить значение элемент типа NMGLubyte, доступного по указателю (NMGLubyte\*)pixels +i\*(width\*tSize+paddings)+ j, где p -- указатель на текстурное изображение уровня level активного текстурного объекта, а pixels -- значение аргумента pixels.

### Функция nmglActiveTexture

#### Прототип функции

void nmglActiveTexture (NMGLenum texture);

#### Назначение

Функция выбирает текстурный модуль для последующей модификации функциями текстурирования.

#### Входные данные

**NMGLenum texture** -- идентификатор текстурного модуля, устанавливаемого в качестве активного. Значение аргумента texture представляет собой символическую константу вида NMGL_TEXTUREi. Значение константы NMGL_TEXTUREi определяется по формуле NMGL_TEXTUREi = NMGL_TEXTURE0 + i (i лежит в диапазоне от 0 до k − 1, где k - поддерживаемое число модулей текстур, зависящее от реализации. Значение k определяется значением параметра NMGL_MAX_TEXTURE_UNITS. По умолчанию активным модулем текстуры является модуль с идентификатором NMGL_TEXTURE0. Минимальное количество поддерживаемых модулей текстур равно 1. Если в функцию передано неподдерживаемое значение texture, должна быть сформирована ошибка NMGL_INVALID_ENUM.

#### Выходные данные

Отсутствуют

#### Возвращаемое значение

Отсутствует

#### Алгоритм

Функция текстурирования nmglActiveTexture работает в соответствии со следующим алгоритмом:

1)  Получить значение глобальной переменной контекста.

```{=html}
<!-- -->
```
1)  Проверить корректность значений входного аргумента. В случае, если аргумент имеет недопустимое значение, установить соответствующий признак ошибки в контексте и завершить выполнение функции.

2)  Заменить идентификатор (имя) активного текстурного модуля в структуре контекста на значение, указанное в аргументе texture. *Передать на процессорное ядро NMPU1 команду и данные для установки идентификатора активного текстурного модуля в структуре контекста NMPU1.*

    *Процессорное ядро NMPU1 при получении команды от NMPU0 выполняет установку идентификатора активного текстурного модуля в структуре контекста в соответствии с полученным значением.*

### Функция nmglGenTextures

#### Прототип функции

void nmglGenTextures (NMGLsizei n, NMGLuint \*textures);

#### Назначение

Функция обеспечивает генерацию имён текстурных объектов.

В прикладной программе могут использоваться только текстурные объекты с именами, сгенерированными данной функцией. Корректное имя текстурного объекта представляет собой положительное целое число от 0 до NMGL_MAX_TEX_OBJECTS не включительно. Функция не ограничена в количестве генерируемых имён, и в случае её множественных вызовов при превышении максимального количества имён объектов ошибок не генерирует.

Текстурный объект с именем 0 создаётся по умолчанию и может быть использован без обращения к функции nmglGenTextures (также по умолчанию текстурный объект 0 привязывается к нулевому текстурному модулю).

#### Входные данные

**NMGLsizei n** - определяет, сколько имён текстурных объектов должно быть сгенерировано.

#### Выходные данные

**NMGLuint \*textures** - указателем на массив генерируемых имён текстурных объектов.

#### Возвращаемое значение

Отсутствует

#### Алгоритм

Алгоритм работы функции состоит в следующем:

1.  Получить указатель на объект контекста.

2.  Выполнить следующие действия n раз:

    1.  Увеличить значение поля lastTexName контекста на 1 (по умолчанию равно 0).

    2.  Присвоить области памяти по указателю **textures** значение поля lastTexName контекста

    3.  Передвинуть указатель textures на размер одной переменной типа NMGLint (увеличить значение указателя **textures** на единицу)**.**

### Функция nmglBindTexture

#### Прототип функции

void nmglBindTexture (NMGLenum target, NMGLuint texture);

#### Назначение

Функция осуществляет привязку именованного текстурного объекта к активному текстурному модулю. Перед привязкой в случае если объект не был создан, должны осуществляться его создание и первоначальная инициализация. В связи с использованием статической памяти в текущей реализации эти действия осуществляются для всех текстурных объектов при инициализации контекста.

#### Входные данные

**NMGLenum target** - определяет тип текстурного объекта. Должен иметь значение NMGL_TEXTURE_2D.

**GLuint texture** - определяет имя текстурного объекта.

#### Выходные данные

Отсутствуют

#### Возвращаемое значение

Отсутствует

#### Алгоритм работы

Алгоритм работы функции состоит в следующем:

1.  Получить указатель на объект контекста.

2.  Обнулить возвращаемый указатель на текстурный объект.

3.  Осуществить проверку аргументов:

    1.  Если аргумент target имеет значение, не равное NMGL_TEXTURE_2D, то записать в поле ошибки контекста значение NMGL_INVALID_ENUM и завершить работу

    2.  Если аргумент texture имеет значение, большее чем значение поля lastTexName контекста, то записать в поле ошибки контекста значение NMGL_INVALID_VALUE и завершить работу

4.  Определить, был ли уже создан текстурный объект с именем texture.

    1.  Если аргумент texture имеет значение, большее либо равное NMGL_MAX_TEX_OBJECTS, то присвоить возвращаемому указателю на текстурный объект значение NULL. В противном случае присвоить возвращаемому указателю на текстурный объект значение, соответствубщее адресу элемента массива текстурных объектов контекста с индексом texture.

5.  Если значение возвращаемого указателя на текстурный объект равно NULL, то записать в поле ошибки контекста значение NMGL_OUT_OF_MEMORY и завершить работу

6.  Если значение поля target текстурного объекта, доступного п овозвразаемому указателю на текстурный объект, не совпадает со значением аргумента tatget, то записать в поле ошибки контекста значение NMGL_INVALID_OPERATION и завершить работу

7.  Присвоить значению поля boundTexObject значение возвращаемого указателя на текстурный объект

8.  *Передать команду привязки текстуры на второй процессор (nm1).*

*Процессор nm1 при получении команды привязки текстуры дожен осуществить следующие действия:*

1.  *Присвоить значению поля boundTexObject значение полученного вместе с командной, указателя на текстурный объект.*

### Функция nmglClientActiveTexture

#### Прототип функции

void nmglClientActiveTexture (NMGLenum texture);

#### Назначение

Данная функция используется для того, чтобы выбрать параметры, которые должны быть модифицированы с помощью команды nmglTexCoordPointer, а также массив, на который влияют команды nmglEnableClientState и nmglDisableClientState, использующие аргумент NMGL_TEXTURE_COORD_ARRAY.

#### Входные данные

**NMGLenum texture** - текстурный модуль (например, NMGL_TEXTURE0). Если в качестве аргумента передано неподдерживаемое значение, должна быть сгенерирована ошибка NMGL_INVALID_ENUM.

#### Выходные данные

Отсутствуют

#### Возвращаемое значение

Отсутствует

#### Алгоритм

Функция текстурирования nmglClientActiveTexture работает в соответствии со следующим алгоритмом:

1)  Получить значение глобальной переменной контекста.

```{=html}
<!-- -->
```
3)  Проверить корректность значений входного аргумента. В случае, если аргумент имеет недопустимое значение, установить соответствующий признак ошибки в контексте и завершить выполнение функции.

4)  Заменить идентификатор (имя) клиентского активного текстурного модуля в структуре контекста на значение, указанное в аргументе texture.

### Функция nmglMultiTexCoord2f

#### Прототип функции

void nmglMultiTexCoord2f (NMGLenum target, NMGLfloat s, NMGLfloat t);

#### Назначение

Функция nmglMultiTexCoord2f предназначена для установки текстурных координат при использовании мультитекстурирования. Функция устанавливает текущее значение однородных текстурных координат (s,t) для заданного модуля текстур.

#### Входные данные

**NMGLenum texture** -- символическая константа вида NMGL_TEXTUREi, где i определяет номер изменяемого набора текстурных координат. Значение константы NMGL_TEXTUREi определяется по формуле NMGL_TEXTUREi = NMGL_TEXTURE0 + i (i лежит в диапазоне от 0 до k − 1, где k - поддерживаемое число модулей текстур, зависящее от реализации. Значение k определяется значением параметра NMGL_MAX_TEXTURE_UNITS. Минимальное количество поддерживаемых модулей текстур равно 1. Если в аргументе texture передано некорректное значение, поведение функции не определено.

**NMGLfloat s** - значение текстурной координаты s.

**NMGLfloat t** - значение текстурной координаты t.

#### Выходные данные

Отсутствуют

#### Возвращаемое значение

Отсутствует

#### Алгоритм

Функция текстурирования nmglMultiTexCoord2f работает в соответствии со следующим алгоритмом:

1)  Получить значение глобальной переменной контекста.

```{=html}
<!-- -->
```
5)  Проверить корректность значений входных аргументов. В случае, если аргументы имеют недопустимые значения, установить соответствующий признак ошибки в контексте и завершить выполнение функции.

6)  Получить идентификатор активного текстурного модуля в контексте.

7)  Скопировать значения текстурных координат s и t, переданных в аргументах функции в соответствующие поля элемента массива текущих текстурных координат контекста. Значения текстурных координат поместить в элемент массива, соответствующий активному текстурному модулю.

### Функция nmglTexCoordPointer

#### Прототип функции

void nmglTexCoordPointer (NMGLint size, NMGLenum type, NMGLsizei stride, const void \*pointer);

#### Назначение

Функция nmglTexCoordPointer задает расположение и формат данных массива текстурных координат для использования при отрисовке. Параметр size определяет количество координат в наборе координат текстуры. Параметр type задает тип данных каждой координаты текстуры. Параметр stride задает шаг в байтах между наборами координат текстуры.

При указании массива координат текстуры размер, тип, шаг и указатель сохраняются как состояние на стороне клиента в дополнение к текущей привязке буферного объекта массива вершин.

Чтобы включить или отключить массив координат текстуры, необходимо вызвать функции nmglEnableClientState или nmglDisableClientState с аргументом NMGL_TEXTURE_COORD_ARRAY. Если этот параметр включен, массив координат текстуры используется, когда вызываются функции nmglDrawArrays, nmglDrawElements.

#### Входные данные

**NMGLint size** - число координат для каждого элемента массива, должно быть равно 2. Если в функцию передано другое значение параметра, генерируется ошибка NMGL_INVALID_VALUE.

**NMGLenum type** - тип данных для каждой координаты текстуры, должен иметь значение NMGL_FLOAT.

**NMGLsizei stride** - смещение в байтах между последовательными наборами координат текстуры. Если шаг равен 0, то элементы массива считаются плотно упакованными. Единственное доступное значение - 0.

**const void \*pointer** - указатель на первую координату первого набора текстурных координат в массиве. Начальное значение равно 0.

#### Выходные данные

Отсутствуют

#### Возвращаемое значение

Отсутствует

#### Алгоритм

Функция текстурирования nmglTexCoordPointer работает в соответствии со следующим алгоритмом:

1)  Получить значение глобальной переменной контекста.

```{=html}
<!-- -->
```
8)  Проверить корректность значений входных аргументов. В случае, если аргументы имеют недопустимые значения, установить соответствующий признак ошибки в контексте и завершить выполнение функции.

9)  Получить идентификатор клиентского активного текстурного модуля в контексте.

10) Скопировать данные массива текстурных координат, переданные в аргументах функции, в поле контекста (массив), используемое для хранения массивов текстурных координат текстурных модулей. Информацию о переданном массиве текстурных координат поместить в элемент, соответствующий клиентскому активному текстурному модулю.

### Функция nmglMultiTexCoord2fv

#### Прототип функции

void nmglMultiTexCoord2fv (NMGLenum target, const NMGLfloat \*v);

#### Назначение

Функция nmglMultiTexCoord2fv предназначена для установки текстурных координат при использовании мультитекстурирования. Функция устанавливает текущее значение однородных текстурных координат s и t для заданного модуля текстур.

#### Входные данные

**NMGLenum texture** -- символическая константа вида NMGL_TEXTUREi, где i определяет номер изменяемого набора текстурных координат. Значение константы NMGL_TEXTUREi определяется по формуле NMGL_TEXTUREi = NMGL_TEXTURE0 + i (i лежит в диапазоне от 0 до k − 1, где k - поддерживаемое число модулей текстур, зависящее от реализации. Значение k определяется значением параметра NMGL_MAX_TEXTURE_UNITS. Минимальное количество поддерживаемых модулей текстур равно 1. Если в аргументе texture передано некорректное значение, поведение функции не определено.

**const NMGLfloat \*v** - указатель на массив из двух элементов, определяющих значения текстурных координат s и t.

#### Выходные данные

Отсутствуют

#### Возвращаемое значение

Отсутствует

#### Алгоритм

Функция текстурирования nmglMultiTexCoord2fv работает в соответствии со следующим алгоритмом:

1)  Получить значение глобальной переменной контекста.

```{=html}
<!-- -->
```
11) Проверить корректность значений входных аргументов. В случае, если аргументы имеют недопустимые значения, установить соответствующий признак ошибки в контексте и завершить выполнение функции.

12) Получить идентификатор активного текстурного модуля в контексте.

13) Скопировать значения текстурных координат, переданных в аргументе v соответствующие поля элемента массива текущих текстурных координат контекста. При этом в элементе 0 по указателю v хранится значение текстурной координаты s, а в элементе 1 - значение текстурной координаты t. Значения текстурных координат поместить в элемент массива, соответствующий активному текстурному модулю.

### Функция nmglTexParameteri

#### Прототип функции

void nmglTexParameteri (NMGLenum target, NMGLenum pname, NMGLint param);

#### Назначение

Функция nmglTexParameteri устанавливает параметры текстурирования, определяющие способы обработки текстурного массива в процессе применения его к фрагментам.

#### Входные данные

**NMGLenum target** - тип текстуры. Данный аргумент должен принимать значение NMGL_TEXTURE_2D.

**NMGLenum pname** - символическая константа, определяющая наименование устанавливаемого параметра. Возможные значения: NMGL_TEXTURE_WRAP_S, NMGL_TEXTURE_WRAP_T, NMGL_TEXTURE_MIN_FILTER, NMGL_TEXTURE_MAG_FILTER.

**NMGLint param** - новое значение параметра. Параметры обработки границ NMGL_TEXTURE_WRAP_S и NMGL_TEXTURE_WRAP_T могут принимать только значения NMGL_REPEAT и NMGL_CLAMP_TO_EDGE. Поддерживаются все режимы фильтрации. Возможные значения параметра NMGL_TEXTURE_MIN_FILTER: NMGL_NEAREST, NMGL_LINEAR, NMGL_NEAREST_MIPMAP_NEAREST, NMGL_NEAREST_MIPMAP_LINEAR, NMGL_LINEAR_MIPMAP_NEAREST, NMGL_LINEAR_MIPMAP_LINEAR. Возможные значения параметра NMGL_TEXTURE_MAG_FILTER: NMGL_NEAREST, NMGL_LINEAR. Если значение передаваемого аргумента отличается от допустимого, генерируется ошибка NMGL_INVALID_VALUE.

#### Выходные данные

Отсутствуют

#### Возвращаемое значение

Отсутствует

#### Алгоритм

Функция текстурирования nmglTexParameteri работает в соответствии со следующим алгоритмом:

1)  Получить значение глобальной переменной контекста.

```{=html}
<!-- -->
```
14) Проверить корректность значений входных аргументов. В случае, если аргументы имеют недопустимые значения, установить соответствующий признак ошибки в контексте и завершить выполнение функции.

15) Получить идентификатор текстурного объекта, привязанного к активному текстурному модулю, в контексте.

16) Используя идентификатор текстурного объекта, установить значение поля (параметр обработки границ или режим фильтрации), указанного в аргументе pname, равным значению аргумента param. *Передать на процессорное ядро NMPU1 команду и данные для установки в структуре контекста NMPU1 значения поля (параметра обработки границ или режима фильтрации), указанного в аргументе pname, в значение аргумента param.*

    *Процессорное ядро NMPU1 при получении команды от NMPU0 выполняет установку в структуре контекста NMPU1 значения поля (параметра обработки границ или режима фильтрации), указанного в аргументе pname, в значение аргумента param.*

### Функция nmglTexEnvfv

#### Прототип функции

void nmglTexEnvfv (NMGLenum target, NMGLenum pname, const NMGLfloat \*params);

#### Назначение

Функция nmglTexEnvfv предназначена для установки параметров текстурного окружения, определяющего, каким образом интерпретируются значения текстуры при текстурировании фрагментов. Данная функция устанавливает текущее значение компонент цвета текстурного окружения, обозначаемого С~c~ и A~c~. Значения С~c~ и A~c~ используются в качестве аргументов функций текстурирования, устанавливаемых с помощью функции nmglTexEnvi с параметром NMGL_TEXTURE_ENV_MODE.

#### Входные данные

**NMGLenum target** - данный аргумент должен принимать значение NMGL_TEXTURE_ENV.

**NMGLenum pname** - символическая константа, определяющая наименование устанавливаемого параметра. Данный аргумент может принимать единственное значение NMGL_TEXTURE_ENV_COLOR.

**NMGLfloat \*params** - указатель на массив значений параметра. Значение текущего цвета текстурного окружения задается массивом из четырех чисел, каждое из которых устанавливает одну из компонент (RGBA). Значения должны лежать в диапазоне \[0, 1\]. Значения, выходящие за диапазон, приводятся к ближайшему граничному значению диапазона (0 или 1).

#### Выходные данные

Отсутствуют

#### Возвращаемое значение

Отсутствует

#### Алгоритм

Функция текстурирования nmglTexEnvfv работает в соответствии со следующим алгоритмом:

1)  Получить значение глобальной переменной контекста.

```{=html}
<!-- -->
```
17) Проверить корректность значений входных аргументов. В случае, если аргументы имеют недопустимые значения, установить соответствующий признак ошибки в контексте и завершить выполнение функции.

18) Получить идентификатор активного текстурного модуля в контексте.

19) Используя идентификатор, в соответствующем поле активного текстурного модуля установить значение цвета текстурного окружения равным значению аргумента params. Компоненты цветов RGBA расположены по указателю params в следующем порядке: params\[0\] = R, params\[1\] = G, params\[2\] = B, params\[3\] = A. *Передать на процессорное ядро NMPU1 команду и данные для установки в структуре контекста NMPU1 для активного текстурного модуля значения цвета текстурного окружения равным значению аргумента params.*

    *Процессорное ядро NMPU1 при получении команды от NMPU0 выполняет установку в структуре контекста NMPU1 значения цвета текстурного окружения для активного текстурного модуля.*

### Функция nmglTexEnvi

#### Прототип функции

void nmglTexEnvi (NMGLenum target, NMGLenum pname, NMGLint param);

#### Назначение

Функция nmglTexEnvi предназначена для установки параметров текстурного окружения, определяющего, каким образом интерпретируются значения текстуры при текстурировании фрагментов. Данная функция устанавливает вид функции текстурирования, определяющей способ вычисления результирующего цвета фрагмента при наложении текстуры.

#### Входные данные

**NMGLenum target** - данный аргумент должен принимать значение NMGL_TEXTURE_ENV.

**NMGLenum pname** - символическая константа, определяющая наименование устанавливаемого параметра. Данный аргумент может принимать единственное значение NMGL_TEXTURE_ENV_MODE.

**NMGLint param** - новое значение параметра. Возможные значения: NMGL_MODULATE, NMGL_REPLACE, NMGL_DECAL, NMGL_BLEND, NMGL_ADD.

#### Выходные данные

Отсутствуют

#### Возвращаемое значение

Отсутствует

#### Алгоритм

Функция текстурирования nmglTexEnvi работает в соответствии со следующим алгоритмом:

1)  Получить значение глобальной переменной контекста.

```{=html}
<!-- -->
```
20) Проверить корректность значений входных аргументов. В случае, если аргументы имеют недопустимые значения, установить соответствующий признак ошибки в контексте и завершить выполнение функции.

21) Получить идентификатор активного текстурного модуля в контексте.

22) Используя идентификатор, в соответствующем поле активного текстурного модуля установить идентификатор функции текстурирования в значение, соответствующее значению аргумента param. Кроме того, сохранить значение параметра param в соответствующем поле (имя функции текстурирования) активного текстурного модуля. *Передать на процессорное ядро NMPU1 команду и данные для установки в структуре контекста NMPU1 для активного текстурного модуля значения функции текстурирования, соответствущего значению аргумента params.*

    *Процессорное ядро NMPU1 при получении команды от NMPU0 выполняет установку в структуре контекста NMPU1 значения функции текстурирования для активного текстурного модуля.*

### Функция nmglGetTexParameteriv

#### Прототип функции

void nmglGetTexParameteriv (NMGLenum target, NMGLenum pname, NMGLint \*params);

#### Назначение

Функция nmglGetTexParameteriv предназначена для получения текущих значений параметров текстурирования. Данная функция используется для получения текущих значений режимов обработки границ и параметров фильтрации для двумерных текстур.

#### Входные данные

**NMGLenum target** - данный аргумент определяет тип текущего привязанного текстурного объекта и должен принимать значение NMGL_TEXTURE_2D.

**NMGLenum pname** - символическая константа, определяющая наименование параметра, значение которого требуется получить. Возможные значения:NMGL_TEXTURE_MIN_FILTER, NMGL_TEXTURE_MAG_FILTER, NMGL_TEXTURE_WRAP_S, NMGL_TEXTURE_WRAP_T.

#### Выходные данные

**NMGLint params** - указатель на область памяти, в которую необходимо поместить значение считываемого параметра текстурирования.

#### Возвращаемое значение

Отсутствует

#### Алгоритм

Функция текстурирования nmglGetTexParameteriv работает в соответствии со следующим алгоритмом:

1)  Получить значение глобальной переменной контекста.

```{=html}
<!-- -->
```
23) Проверить корректность значений входных аргументов. В случае, если аргументы имеют недопустимые значения, установить соответствующий признак ошибки в контексте и завершить выполнение функции.

24) Получить идентификатор текстурного объекта, привязанного к активному текстурному модулю, в контексте.

25) Используя идентификатор текстурного объекта, получить значение поля (параметр обработки границ или режим фильтрации), указанного в аргументе pname, и записать его по указателю, переданному в аргументе params.

### Функция nmglGetTexEnviv

#### Прототип функции

void nmglGetTexEnviv (NMGLenum env, NMGLenum pname, NMGLint \*params);

#### Назначение

Функция nmglGetTexEnviv предназначена для получения текущих значений параметров текстурного окружения. Данная функция используется для получения текущего значения параметра NMGL_TEXTURE_ENV_MODE, определяющего вид функции текстурирования.

#### Входные данные

**NMGLenum env** - данный аргумент должен принимать значение NMGL_TEXTURE_ENV.

**NMGLenum pname** - символическая константа, определяющая наименование параметра, значение которого требуется получить. Данный аргумент может принимать единственное значение NMGL_TEXTURE_ENV_MODE.

#### Выходные данные

**NMGLint \*params** - указатель на область памяти, в которую необходимо поместить значение считываемого параметра.

#### Возвращаемое значение

Отсутствует

#### Алгоритм

Функция текстурирования nmglGetTexEnviv работает в соответствии со следующим алгоритмом:

1)  Получить значение глобальной переменной контекста.

```{=html}
<!-- -->
```
26) Проверить корректность значений входных аргументов. В случае, если аргументы имеют недопустимые значения, установить соответствующий признак ошибки в контексте и завершить выполнение функции.

27) Получить идентификатор активного текстурного модуля в контексте.

28) Используя идентификатор, скопировать значение имени функции текстурирования цвета текстурного окружения из соответствующего поля активного текстурного модуля по указателю, переданному в аргументе params.

### Функция nmglGetTexEnvfv

#### Прототип функции

void nmglGetTexEnvfv (NMGLenum env, NMGLenum pname, NMGLfloat \*params);

#### Назначение

Функция nmglGetTexEnvfv предназначена для получения текущих значений параметров текстурного окружения. Данная функция используется для получения текущего значения параметра NMGL_TEXTURE_ENV_COLOR, определяющего цвет текстурного окружения.

#### Входные данные

**NMGLenum env** - данный аргумент должен принимать значение NMGL_TEXTURE_ENV.

**NMGLenum pname** - символическая константа, определяющая наименование параметра, значение которого требуется получить. Данный аргумент может принимать единственное значение NMGL_TEXTURE_ENV_COLOR.

#### Выходные данные

**NMGLfloat \*params** - указатель на область памяти, в которую необходимо поместить значение считываемого параметра.

#### Возвращаемое значение

Отсутствует

#### Алгоритм

Функция текстурирования nmglGetTexEnvfv работает в соответствии со следующим алгоритмом:

1)  Получить значение глобальной переменной контекста.

```{=html}
<!-- -->
```
29) Проверить корректность значений входных аргументов. В случае, если аргументы имеют недопустимые значения, установить соответствующий признак ошибки в контексте и завершить выполнение функции.

30) Получить идентификатор активного текстурного модуля в контексте.

31) Используя идентификатор, скопировать значение цвета текстурного окружения из соответствующего поля активного текстурного модуля по указателю, переданному в аргументе params. Компоненты цветов RGBA расположить по указателю params в следующем порядке: params\[0\] = R, params\[1\] = G, params\[2\] = B, params\[3\] = A.

Описание и алгоритмы работы функций расширения EXT_paletted_texture
-------------------------------------------------------------------

Раздел содержит описание и алгоритмы функций, входящих в состав расширения EXT_paletted_texture спецификации OpenGL SC 1.0.1 и позволяющих задавать текстурные изображения с помощью палитры текстур.

### Функция nmglColorTableEXT

#### Прототип функции

void nmglColorTableEXT (NMGLenum target, NMGLenum internalformat, NMGLsizei width, NMGLenum format, NMGLenum type, const void \*data)

#### Назначение

Функция nmglColorTableEXT предназначена для задания палитры цветов для текстурного объекта.

Если длина палитры больше, чем диапазон цветов индексов цвета в текстурной памяти, то некоторые элементы палитры не будут использоваться.

Если наоборот, длина палитры меньше диапазона индексов цвета, то старшие биты текстурных данных будут игнорироваться, и при доступе к палитре будет использоваться только нужное количество бит.

#### Входные данные

**NMGLenum target** -- определяет тип текстуры, для которой задаётся палитра. Единственное поддерживаемое значение: NMGL_TEXTURE_2D.

**NMGLenum internalformat --** определяет формат и точность задания палитры, хранимой в текстурном объекте. Единственное поддерживаемое значение: NMGL_RGBA.

**NMGLsizei width --** определяет длину палитры в текселях. Длина должна быть степенью двойки и больше либо равна 1. По умолчанию каждый текстурный объект имеет палитру из одного текселя, каждая компонента которого имеет значение 1. Реализация ограничивает максимальное возможное значения аргумента width константой NMGL_MAX_PALETTE_WIDTH.

**NMGLenum format --** определяет количество компонент в одном текселе. Единственное поддерживаемое значение: NMGL_RGBA.

**NMGLenum type --** определяет формат представления компонент текселя. Единственное поддерживаемое значение - NMGL_UNSIGNED_BYTE.

**const void \*data --** указатель на массив данных текселей загружаемой палитры.

#### Выходные данные

Отсутствуют

#### Возвращаемое значение

Отсутствует

#### Алгоритм

Функция nmglColorTableEXT работает в соответствии со следующим алгоритмом:

1.  Получить указатель на контекст

2.  Проверить корректность входных аргументов:

    1.  Если аргумент target имеет значение, отличное от NMGL_TEXTURE_2D, то установить переменной ошибки контекста значение NMGL_INVALID_ENUM и завершить работу.

    2.  Если аргумент type имеет значение, отличное от NMGL_UNSIGNED_BYTE, то установить переменной ошибки контекста значение NMGL_INVALID_ENUM и завершить работу.

    3.  Если аргумент internalformat имеет значение, отличное от NMGL_RGBA, то установить переменной ошибки контекста значение NMGL_INVALID_VALUE и завершить работу.

    4.  Если значения аргументов format и internalformat не совпадают, то установить переменной ошибки контекста значение NMGL_INVALID_VALUE и завершить работу.

    5.  Если значение аргумента width \< 0, то установить переменной ошибки контекста значение NMGL_INVALID_VALUE и завершить работу.

    6.  Если значение аргумента width \> NMGL_MAX_PALETTE_WIDTH, то установить переменной ошибки контекста значение NMGL_OUT_OF_MEMORY и завершить работу.

3.  Установить ширину палитры активного текстурного объекта (АТО) равной width.

4.  Инициализировать указатель на тексели палитры АТО.

5.  Записать width текселей в палитру текстурного объекта из массива, доступного через аргумент data.

### Функция nmglColorSubTableEXT

#### Прототип функции

void nmglColorSubTableEXT (NMGLenum target, NMGLsizei start, NMGLsizei count, NMGLenum format, NMGLenum type, const void \*data)

#### Назначение

Функция обеспечивает возможность замены части палитры новыми значениями.

#### Входные данные

**NMGLenum target** -- определяет тип текстуры, для которой задаётся палитра. Единственное поддерживаемое значение: NMGL_TEXTURE_2D.

**NMGLsizei start --** определяет индекс внутри массива текселей активного текстурного объекта, начиная с которого будет осуществляться запись новых значений из масива, доступного через аргумент data. Представляет собой целое неотрицательное число.

**NMGLsizei count --** определяет количество текселей, выбранных для копирования из массива, доступного через параметр data. В случае, если start+count превышает длину палитры активного текстурного объекта, то будут изменены все тексели, от текселя с индексом start до конца палитры.

**NMGLenum format --** определяет количество компонент в одном текселе. Единственное поддерживаемое значение: NMGL_RGBA.

**NMGLenum type --** определяет формат представления компонент текселя. Единственное поддерживаемое значение - NMGL_UNSIGNED_BYTE.

**const void \*data --** указатель на массив данных текселей загружаемой палитры.

#### Выходные данные

Отсутствуют

#### Возвращаемое значение

Отсутствует

#### Алгоритм

Функция работает в соответствии со следующим алгоритмом:

1.  Получить указатель на контекст

2.  Проверить корректность входных аргументов:

    1.  Если аргумент target имеет значение, отличное от NMGL_TEXTURE_2D, то установить переменной ошибки контекста значение NMGL_INVALID_ENUM и завершить работу.

    2.  Если аргумент type имеет значение, отличное от NMGL_UNSIGNED_BYTE, то установить переменной ошибки контекста значение NMGL_INVALID_ENUM и завершить работу.

    3.  Если аргумент format имеет значение, отличное от NMGL_RGBA, то установить переменной ошибки контекста значение NMGL_INVALID_VALUE и завершить работу.

    4.  Если значение аргумента start меньше нуля или не меньше значения длины палитры активного текстурного объекта, то установить переменной ошибки контекста значение NMGL_INVALID_VALUE и завершить работу.

3.  Записать X текселей из массива, доступного через аргумент data в палитру активного текстурного объекта. Запись осуществлять, начиная с индекса start палитры активного текстурного объекта. X= start, в случае, если start+count не превышает длины палитры активного текстурного объекта. В противном случае X=width-start, где width -- лдина палитры активного текстурного объекта.

### Функция nmglGetColorTableEXT

#### Прототип функции

void nmglGetColorTableEXT (NMGLenum target, NMGLenum format, NMGLenum type,void \*data);

#### Назначение

Функция предназначена для получения указателя на массив текселей палитры активного текстурного объекта.

#### Входные данные

**NMGLenum target** -- определяет тип текстуры, для которой задаётся палитра. Единственное поддерживаемое значение: NMGL_TEXTURE_2D.

**NMGLenum format --** определяет количество компонент в одном текселе. Единственное поддерживаемое значение: NMGL_RGBA.

**NMGLenum type --** определяет формат представления компонент текселя. Единственное поддерживаемое значение - NMGL_UNSIGNED_BYTE.

**const void \*data --** указатель на массив данных текселей палитры.

#### Выходные данные

Отсутствуют

#### Возвращаемое значение

Отсутствует

#### Алгоритм

Функция работает в соответствии со следующим алгоритмом:

1.  Получить указатель на контекст

2.  Проверить корректность входных аргументов:

    1.  Если аргумент target имеет значение, отличное от NMGL_TEXTURE_2D, то установить переменной ошибки контекста значение NMGL_INVALID_ENUM и завершить работу.

    2.  Если аргумент type имеет значение, отличное от NMGL_UNSIGNED_BYTE, то установить переменной ошибки контекста значение NMGL_INVALID_ENUM и завершить работу.

    3.  Если аргумент format имеет значение, отличное от NMGL_RGBA, то установить переменной ошибки контекста значение NMGL_INVALID_VALUE и завершить работу.

3.  Присвоить аргументу data указатель на палитру активного текстурного объекта.

### Функция nmglGetColorTableParameterivEXT

#### Прототип функции

void nmglGetColorTableParameterivEXT (NMGLenum target, NMGLenum pname, NMGLint \*params);

#### Назначение

Функция предназначена для чтения характеристик реализации расширения EXT_paletted_texture.

#### Входные данные

**NMGLenum target** -- определяет тип текстуры, для которой задаётся палитра. Единственное поддерживаемое значение: NMGL_TEXTURE_2D.

**NMGLenum pname** --код интересующей характеристики

**NMGLint \*params** -- указатель на массив переменных для хранения считанных значений характеристик.

#### Выходные данные

Отсутствуют

#### Возвращаемое значение

Отсутствует

#### Алгоритм

Функция работает в соответствии со следующим алгоритмом:

1.  Получить указатель на контекст

2.  Проверить корректность входных аргументов:

    1.  Если аргумент target имеет значение, отличное от NMGL_TEXTURE_2D, то установить переменной ошибки контекста значение NMGL_INVALID_ENUM и завершить работу.

3.  В зависимости от значения аргумента pname вернуть соответствующее значение:

    1.  Если pname= NMGL_COLOR_TABLE_FORMAT_EXT, то вернуть NMGL_COLOR_INDEX8_EXT.

    2.  Если pname=NMGL_COLOR_TABLE_WIDTH_EXT, то вернуть значение длины палитры активного текстурного объекта.

    3.  Если pname= NMGL_COLOR_TABLE_RED_SIZE_EXT, то вернуть 1.

    4.  Если pname= NMGL_COLOR_TABLE_GREEN_SIZE_EXT, то вернуть 1.

    5.  Если pname= NMGL_COLOR_TABLE_BLUE_SIZE_EXT, то вернуть 1.

    6.  Если pname= NMGL_COLOR_TABLE_ALPHA_SIZE_EXT, то вернуть 1.

    7.  Если pname=NMGL_COLOR_TABLE_LUMINANCE_SIZE_EXT, то вернуть 1.

    8.  Если pname=NMGL_COLOR_TABLE_INTENSITY_SIZE_EXT, то вернуть 1.

Описание и алгоритмы работы функций текстурирования пикселей
------------------------------------------------------------

Данный раздел содержит описание и алгоритмы функций текстурирования пикселей, выполняющих непосредственное закрашивание пикселей примитива в процессе текстурирования при реализации функций из состава \"Библиотеки графических функций текстурирования\" на процессорном ядре NMPU0.

Основной функцией текстурирования пикселей является функция textureTriangle, алгоритм которой соответствует последовательности действий, выполняемых отдельным текстурным модулем в процессе текстурирования пикселей примитива. Основной особенностью алгоритма функции textureTriangle для выполнения на NMPU0 является возможность использования векторного сопроцессора арифметики с плавающей точкой. При этом в реализации nmOpenGL алгоритм текстурирования на процессорном ядре NMPU0 во многом совпадает с алгоритом реализации на NMPU1, однако имеет следующие особенности:

-   Не используется информация о принадлежности пикселей примитиву, поэтому обрабатываются как пиксели, принадлежащие примитиву, так и не принадлежащие примитиву.

-   Обработка пикселей выполняется группами, а не по отдельности. При этом используется векторный сопроцессор арифметики с плавающей точкой. Функции обработки пикселей оперируют массивами значений, соответствующих обрабатываемым группам пикселей, а не отдельными пикселями. Не векторизуются вычисления, неподдерживаемые векторным сопроцессором арифметики с плавающей точкой, а также операции доступа в память для чтения значений текстурных изображений.

### Алгоритм функции textureTriangle

Входными данными функции являются массивы данных о заданном количестве примитивов. Информация о каждом примитиве включает в себя:

-   Оконные координаты вершин примитива (x~0~, y~0~), (x~1~, y~1~), (x~2~, y~2~).

-   Текстурные координаты вершин примитива (s~0~, t~0~), (s~1~, t~1~), (s~2~, t~2~).

-   Координаты w вершин примитива в протранстве отсечения: Wclip~0~, Wclip~1~, Wclip~2~.

-   Основной цвет пикселей треугольника C~f~, A~f.~

Выходными данными функции является массив pDstTriangle, состоящий из массивов пикселей, содержащих текстурированные примитивы.

В процессе текстурирования используются глобальные данные контекста конвейера OpenGL, в том числе:

-   Значения параметров обработки границ WrapS, WrapT.

-   Режим фильтрации при уменьшении текстуры и увеличении текстуры (minFilter, maxFilter)

-   Цвет текстурного окружения (C~с~, A~с~).

-   Массив TexImage, содержащий набор загруженных текстурных изображений разных уровней детализации.

Далее представлен алгоритм функции textureTriangle, реализующей функции текстурного модуля.

1.  Вычислить значения параметров m, n, p, q согласно спецификации OpenGL 1.3 по следующим формулам:

  $$n = \ log2(TexImage\left\lbrack \text{leve}l_{\text{base}} \right\rbrack.width)$$    
  -------------------------------------------------------------------------------------- --
  $$m = \ log2(TexImage\left\lbrack \text{leve}l_{\text{base}} \right\rbrack.height)$$   
  $$p = \max\left\{ n,m \right\} + level_{\text{base}}$$                                 
  $$q = \min\left\{ p,level_{\max} \right\}$$                                            

Данные параметры являются общими для всех примитивов, обрабатываемых текстурным модулем. При расчёте значений n, m, p, q используется массив текстурных изображений TexImage, принадлежащий текстурному объекту, привязанному с помощью функции BindTexture к текстурному модулю в момент текстурирования. Значение level~base~ по умолчанию равно 0, что соответствует текстурному изображению уровня 0. Значение level~max~ по умолчанию равно 1000.

2.  Для каждого текстурируемого примитива, поступаемого на вход функции текстурного модуля, выполнить следующие действия:

    1.  Вычислить размеры primWidth и primHeight прямоугольной области в матрице 32\*32, в которую умещается растеризуемый примитив.

    2.  Вычислить набор коэффициентов для вычисления коэффициента масштабирования (scale factor), используемого для определения уровня детализации (level of detail). Если используется переспективно-корректное текстурирование, то использовать формулы в соответствии с таблицей Таблица 33. В противном случае использовать формулы из таблицы Таблица 35.

    3.  Для каждой из primHeight строк матрицы размером 32\*32, соответствующей текстурируемому примитиву, выполнить следующие действия для primWidth пикселей:

        1.  Вычислить значение координаты центра пикселя xf, yf, по формулам xf = x+0.5, yf = y+0.5.

        2.  Вычислить значение текстурных координат пикселя s и t для пикселя, используя полученные ранее значения коэффициентов для расчёта коэффициента масштабирования. Если выполняется перспективно-корректное текстурирование, использовать формулы из таблицы Таблица 52, в противном случае использовать формулы из таблицы Таблица 53.

Таблица 52 -- Формулы для расчёта текстурных координат для перспективно-корректного текстурирования с исользованием коэффициентов для расчёта коэффициента масштабирования

  $$K = \frac{1}{A2*xf\  + \ B2*yf\  + \ D2}$$                             \(65\)
  ------------------------------------------------------------------------ --------
  $$s(x,y) = K*\ \left( A1_{s}*xf\  + \ B1_{s}*yf\  + \ D1_{s} \right)$$   \(66\)
  $$t(x,y) = K*\left( A1_{t}*xf\  + \ B1_{t}*yf\  + \ D1_{t} \right)$$     \(67\)

Таблица 53 - Формулы для расчёта текстурных координат для текстурирования без учёта перспективной коррекции с применением коэффициентов для расчёта коэффициента масштабирования

  $$s(x,y)\  = \ A_{s}*xf\  + \ B_{s}*yf\  + \ D_{s}$$   \(68\)   
  ------------------------------------------------------ -------- --
  $$t(x,y)\  = \ A_{t}*xf\  + \ B_{t}*yf\  + \ D_{t}$$   \(69\)   

3.  Определить значение константы *c*, определяющей точку перехода режима масштабирования текстуры от уменьшения к увеличению. Если режим фильтрации при увеличении текстуры равен NMGL_LINEAR, а режим фильтрации при уменьшении равен NMGL_NEAREST_MIPMAP_NEAREST или NMGL_NEAREST_MIPMAP_LINEAR, то *c = 0,5*. В противном случае *с = 0*.

4.  Вычислить значения частных производных для функций u(x,y) и v(x,y). Для выполнения шага использовать коэффициенты, вычисленные ранее. Также для вычисления значений частных производных используются значения ширины и высоты (W и H) текстуры нулевого уровня (level~base~) текущего текстурного объекта в текстурном модуле. Если выполняется перспективно-корректное текстурирование, использовать формулы из таблицы **Таблица 46**, в противном случае использовать формулы из таблицы Таблица 55.

Таблица 54 -- Формулы для вычисления производных при перспективно-корректном текстурировании

  $$K = \frac{1}{\left( A2*x\  + \ B2*y\  + \ D2 \right)*\left( A2*x\  + \ B2*y\  + \ D2 \right)}$$                                   
  ----------------------------------------------------------------------------------------------------------------------------------- --
  $$\frac{\partial u}{\partial x} = W*K*\left( A1_{s}*B2\  - \ A2*B1_{s} \right)*y\  + \ A1_{s}*D2\  - \ A2*D1_{s}$$                  
  $$\frac{\partial u}{\partial y} = W*K*\left( B1_{s}*A2\  - \ B2*A1_{s} \right)*x\  + \ B1_{s}*D2\  - \ B2*D1_{s}$$                  
  $$\frac{\partial v}{\partial x} = H*K*\left( \left( A1_{t}*B2\  - \ A2*B1_{t} \right)*y\  + \ A1_{t}*D2\  - \ A2*D1_{t} \right)$$   
  $$\frac{\partial v}{\partial x} = H*K*\left( \left( B1_{t}*A2\  - \ B2*A1_{t} \right)*x\  + \ B1_{t}*D2\  - \ B2*D1_{t} \right)$$   

Таблица 55 - Формулы для вычисления производных без учёта перспективной коррекции

  $$\frac{\partial u}{\partial x} = W*A_{s}$$   
  --------------------------------------------- --
  $$\frac{\partial u}{\partial y} = W*B_{s}$$   
  $$\frac{\partial v}{\partial x} = H*A_{t}$$   
  $$\frac{\partial v}{\partial x} = H*B_{t}$$   

5.  Вычислить значение коэффициента масштабирования *ρ*. Для вычисления коэффициента масштабирования согласно спецификации OpenGL 1.3 наилучший результат даёт формула

  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- --
  $\rho = \max\left\{ \sqrt{\left( \frac{\partial u}{\partial x} \right)^{2} + \left( \frac{\partial v}{\partial x} \right)^{2}},\sqrt{\left( \frac{\partial u}{\partial y} \right)^{2} + \left( \frac{\partial v}{\partial y} \right)^{2}} \right\}$*.*   
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- --

> Ввиду высокой сложности указанной формулы, допускается использовать альтернативный вариант:

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- --
  $\rho\  \approx \ m\text{ax}\{ m_{u},m_{v}\ \} = max\left\{ \max\left\{ \left| \frac{\partial u}{\partial x} \right|,\left| \frac{\partial u}{\partial y} \right| \right\},max\left\{ \left| \frac{\partial v}{\partial x} \right|,\left| \frac{\partial v}{\partial y} \right| \right\} \right\}$.   
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- --

6.  Вычислить значение уровня детализации *λ(x, y)*, с помощью которого определяется, уменьшается текстура или увеличивается. Значение уровня детализации *λ(x, y)* вычисляется по следующим формулам:

  $$\lambda^{'}\left( x,y \right) = \ \log_{2}\left\lceil \rho(x,y) \right\rceil$$   
  ---------------------------------------------------------------------------------- --
  $$\lambda = \ \left\{ \begin{matrix}                                               
  \text{lod}_{\max},\lambda^{'} > \ \text{lod}_{\max} \\                             
  \lambda^{'},\text{lod}_{\min} \leq \lambda^{'} \leq \text{lod}_{\max} \\           
  \text{lod}_{\min},\lambda^{'} < \text{lod}_{\min} \\                               
  undefined,\text{lod}_{\min} > \text{lod}_{\max} \\                                 
  \end{matrix} \right.\ $$                                                           

Если *λ(x, y)* меньше или равно значению константы *c*, то считается, что текстура увеличивается (NMGL_MAGNIFICATION), в противном случае считается, что текстура уменьшается (NMGL_MINIFICATION). Установить признак режима масштабирования текстуры в соответствующее значение.

7.  В зависимости от значения признака режима масштабирования текстуры и режима фильтрации получить текстурное значение для текстурирования пикселя:

    1.  Если установлен режим фильтрации NMGL_NEAREST, то выполняются следующие шаги (в режимах масштабирования текстуры NMGL_MAGNIFICATION или NMGL_MINIFICATION):

        1.  Преобразовать текстурные координаты s и t пикселя в соответствии с режимом обработки границ (wrap mode) с помощью функции wrapCoord. При этом для преобразования использовать ширину и высоту текстуры нулевого уровня (level~base~) текущего текстурного объекта в текущем текстурном модуле.

        2.  Получить текстурное значение из текстуры нулевого уровня с помощью функции getPixelNearest.

    2.  Если установлен режим фильтрации NMGL_LINEAR, то выполняются следующие шаги (в режимах масштабирования текстуры NMGL_MAGNIFICATION или NMGL_MINIFICATION):

        1.  Преобразовать текстурные координаты s и t пикселя в соответствии с режимом обработки границ (wrap mode) с помощью функции wrapCoord. При этом для преобразования использовать ширину и высоту текстуры нулевого уровня (level~base~) текущего текстурного объекта в текущем текстурном модуле.

        2.  Получить текстурное значение из текстуры нулевого уровня с помощью функции getPixelLinear.

    3.  Если установлен режим фильтрации NMGL_NEAREST_MIPMAP_NEAREST или NMGL_LINEAR_MIPMAP_NEAREST и режим масштабирования текстуры соответствует уменьшению текстуры (NMGL_MINIFICATION), то выполняются следующие шаги:

        1.  Определить номер d текстурного массива в mip-карте текущего (привязанного) текстурного объекта для текущего текстурного модуля. d определяется по формуле

  -------------------------------------------------------------------------------------------------------------------------------------------------------------------- --
  $$d = \ \left\{ \begin{matrix}                                                                                                                                       
  \text{leve}l_{\text{base}},\ \lambda\  \leq \frac{1}{2} \\                                                                                                           
  \left\lceil \text{leve}l_{\text{base}} + \ \lambda + 1/2 \right\rceil - 1,\ \lambda > \frac{1}{2},\ level_{\text{base}} + \ \ \text{λ\ }\  \leq 1 + \frac{1}{2} \\   
  q,\ \ \ \lambda > \frac{1}{2},\ level_{\text{base}} + \ \ \text{λ\ } > 1 + \frac{1}{2} \\                                                                            
  \end{matrix} \right.\ $$                                                                                                                                             
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------- --

2.  Преобразовать текстурные координаты s и t пикселя в соответствии с режимом обработки границ (wrap mode) с помощью функции wrapCoord. При этом для преобразования использовать ширину и высоту текстуры с номером d.

3.  Получить текстурное значение из текстуры с номером d с помощью функции getPixelLinear, если установлен режим фильтрации NMGL_LINEAR_MIPMAP_NEAREST, либо с помощью функции getPixelNearest, если установлен режим фильтрации NMGL_NEAREST_MIPMAP_NEAREST.

```{=html}
<!-- -->
```
4.  Если установлен режим фильтрации NMGL_NEAREST_MIPMAP_LINEAR или NMGL_LINEAR_MIPMAP_LINEAR и режим масштабирования текстуры соответствует уменьшению текстуры (NMGL_MINIFICATION), то выполняются следующие шаги:

    1.  Вычислить уровни d~1~ и d~2~ текстур в mip-карте текстур текущего (привязанного) текстурного объекта для текущего текстурного модуля.

  $$d_{1} = \ \left\{ \begin{matrix}                                  
  q, & b + \lambda \geq q\  \\                                        
  \left\lfloor b + \lambda \right\rfloor, & в\ противном\ случае \\   
  \end{matrix} \right.\ $$                                            
  ------------------------------------------------------------------- --
  $$d_{2} = \ \left\{ \begin{matrix}                                  
  q, & b + \lambda \geq q\  \\                                        
  d_{1} + 1, & в\ противном\ случае \\                                
  \end{matrix} \right.\ $$                                            

> b -- значение ширины границы текстурного изображения. Для OpenGL SC b должно быть равным нулю.

2.  Для текстурных изображений с номерами d~1~ и d~2~ вычислить значения текстурных координат (s~1~ и t~1~ для d~1~, s~2~ и t~2~ для для d~2~) путем преобразования текстурных координат s и t пикселя в соответствии с режимом обработки границ (wrap mode) с помощью функции wrapCoord. При этом в процессе преобразования для получения значений координат s~1~ и t~1~ использовать ширину и высоту текстуры с номером d~1~, для получения значений координат s~2~ и t~2~ использовать ширину и высоту текстуры с номером d~2~.

3.  Получить текстурные значения *τ~1~* и *τ~2~* из текстур с вычисленными номерами d~1~ и d~2~ соответственно с помощью функций getPixelLinear, если установлен режим фильтрации NMGL_LINEAR_MIPMAP_LINEAR, либо с помощью функции getPixelNearest, если установлен режим фильтрации NMGL_NEAREST_MIPMAP_LINEAR.

```{=html}
<!-- -->
```
i.  Вычислить итоговое текстурное значение с помощью следующей формулы:

  ----------------------------------------------------------------------------------------------------------------------------------------- --
  $$\tau = \ \left\lbrack 1 - \text{frac}\ \left( \lambda \right) \right\rbrack*\tau_{1} + \text{frac}\left( \lambda \right){*\tau}_{2}$$   
  ----------------------------------------------------------------------------------------------------------------------------------------- --

8.  Преобразовать полученное текстурное значение (C~s~, A~s~), значение цвета текстурного окружения (C~c~, A~c~) и значение цвета входного фрагмента (C~f~, A~f~) из диапазона \[0,255\] к диапазону \[0.0, 1.0\].

9.  Используя полученное текстурное значение (C~s~, A~s~), значение цвета текстурного окружения (C~c~, A~c~) и значение цвета входного фрагмента (C~f~, A~f~), вычислить результирующее значение цвета пикселя после текстурирования (C~v~, A~v~). Значение C~s~, A~s~ определяется базовым внутренним форматом текстуры (см. таблицу Таблица 56). Формула, по которой вычисляется результирующее значение пикселя C~v~, A~v~, зависит от выбранной функции текстурирования, вид которой определяется значением параметра NMGL_TEXTURE_ENV_MODE и базовым внутренним форматом текстурного массива (см. таблицы Таблица 57, Таблица 58).

Таблица 56

  Базовый внутренний формат текстуры   Цвет источника текстуры   
  ------------------------------------ ------------------------- ------
                                       C~s~                      A~s~
  NMGL_ALPHA                           (0, 0, 0)                 A~t~
  NMGL_LUMINANCE                       (L~t~, L~t~, L~t~)        1
  NMGL_LUMINANCE\_ ALPHA               (L~t~, L~t~, L~t~)        A~t~
  NMGL_RGB                             (R~t~, G~t~, B~t~)        1
  NMGL_RGBA                            (R~t~, G~t~, B~t~)        A~t~

Таблица 57 - Определение функций NMGL_REPLACE, NMGL_MODULATE, NMGL_DECAL

+------------------------------------+----------------+---------------------+-------------------------------------+
| Базовый внутренний формат текстуры | Функция        | Функция             | Функция                             |
|                                    |                |                     |                                     |
|                                    | NMGL_REPLACE   | NMGL_MODULATE       | NMGL_DECAL                          |
+====================================+================+=====================+=====================================+
| NMGL_ALPHA                         | *C~v\ =~ C~f~* | *C~v\ =~ C~f~*      | Не определена                       |
|                                    |                |                     |                                     |
|                                    | *A~v\ =~ A~s~* | *A~v\ =~ A~f~ A~s~* |                                     |
+------------------------------------+----------------+---------------------+-------------------------------------+
| NMGL_LUMINANCE                     | *C~v\ =~ C~s~* | *C~v\ =~ C~f~ C~s~* | Не определена                       |
|                                    |                |                     |                                     |
|                                    | *A~v\ =~ A~f~* | *A~v\ =~ A~f~*      |                                     |
+------------------------------------+----------------+---------------------+-------------------------------------+
| NMGL_LUMINANCE\_ ALPHA             | *C~v\ =~ C~s~* | *C~v\ =~ C~f~ C~s~* | Не определена                       |
|                                    |                |                     |                                     |
|                                    | *A~v\ =~ A~s~* | *A~v\ =~ A~f~ A~s~* |                                     |
+------------------------------------+----------------+---------------------+-------------------------------------+
| NMGL_RGB                           | *C~v\ =~ C~s~* | *C~v\ =~ C~f~ C~s~* | *C~v\ =~ C~s~*                      |
|                                    |                |                     |                                     |
|                                    | *A~v\ =~ A~f~* | *A~v\ =~ A~f~*      | *A~v\ =~ A~f~*                      |
+------------------------------------+----------------+---------------------+-------------------------------------+
| NMGL_RGBA                          | *C~v\ =~ C~s~* | *C~v\ =~ C~f~ C~s~* | *C~v\ =~ C~f~ (1 -- A~s~)+C~s~A~s~* |
|                                    |                |                     |                                     |
|                                    | *A~v\ =~ A~s~* | *A~v\ =~ A~f~ A~s~* | *A~v\ =~ A~f~*                      |
+------------------------------------+----------------+---------------------+-------------------------------------+

Таблица 58 - Определение функций NMGL_BLEND, NMGL_ADD

+------------------------------------+--------------------------------------+----------------------+
| Базовый внутренний формат текстуры | Функция                              | Функция              |
|                                    |                                      |                      |
|                                    | NMGL_BLEND                           | NMGL_ADD             |
+====================================+======================================+======================+
| NMGL_ALPHA                         | *C~v\ =~ C~f~*                       | *C~v~ = C~f~*        |
|                                    |                                      |                      |
|                                    | *A~v\ =~ A~f~ A~s~*                  | *A~v~=A~f~ A~s~*     |
+------------------------------------+--------------------------------------+----------------------+
| NMGL_LUMINANCE                     | *C~v~ = C~f~ (1 - C~s~) + C~c~ C~s~* | *C~v~ = C~f~ + C~s~* |
|                                    |                                      |                      |
|                                    | *A~v~ = A~f~*                        | *A~v~ = A~f~*        |
+------------------------------------+--------------------------------------+----------------------+
| NMGL_LUMINANCE\_ ALPHA             | *C~v~ = C~f~ (1 - C~s~) + C~c~ C~s~* | *C~v~ = C~f~ + C~s~* |
|                                    |                                      |                      |
|                                    | *A~v~ = A~f~ A~s~*                   | *A~v~ = A~f~ A~s~*   |
+------------------------------------+--------------------------------------+----------------------+
| NMGL_RGB                           | *C~v~ = C~f~ (1 - C~s~) + C~c~ C~s~* | *C~v~ = C~f~ + C~s~* |
|                                    |                                      |                      |
|                                    | *A~v~ = A~f~*                        | *A~v~ = A~f~*        |
+------------------------------------+--------------------------------------+----------------------+
| NMGL_RGBA                          | *C~v~ = C~f~ (1 - C~s~) + C~c~ C~s~* | *C~v~ = C~f~ + C~s~* |
|                                    |                                      |                      |
|                                    | *A~v~ = A~f~ A~s~*                   | *A~v~ = A~f~ A~s~*   |
+------------------------------------+--------------------------------------+----------------------+

10. Заменить значение цвета фрагмента (пикселя) в треугольнике на полученное значение цвета пикселя после текстурирования (C~v~, A~v~).

### Алгоритм функции wrapCoord

Функция wrapCoord выполняет приведение значений элементов массива текстурных координат к значению из диапазона возможных значений в зависимости от размера текстуры и используемого режима обработки границ. На вход функции поступают следующие параметры: массив значений текстурной координаты для оси s или t, размер текстуры по оси s или t, режим обработки границ. Функция возвращает массив приведённых значений текстурной координаты. Для каждого элемента массива текстурных значений выполняется следущая последовательность действий.

5.  Вычислить максимально возможное значение maxVal текстурной координаты:

  --------------------------------------------- --
  $minVal = \frac{1}{\text{AxisSize}}*0.5$*,*   
  --------------------------------------------- --

> где AxisSize -- размер текстуры по оси Axis (x или y).

6.  Вычислить минимально возможное значение minVal текстурной координаты:

  -------------------------------- --
  $$\text{maxVal} = 1 - minVal$$   
  -------------------------------- --

7.  Если используется режим обработки границ NMGL_REPEAT, то вычислить результирующее значение resVal координаты по следующей формуле:

  ----------------------------------------------------------- --
  $$resVal = \ curVal - floor\left( \text{curVal} \right)$$   
  ----------------------------------------------------------- --

8.  Если используется режим обработки границ NMGL_CLAMP_TO_EDGE, то результирующее значение resVal вычисляется в соответствии со следующими правилами.

  ------------------------------------- --
  $$resVal = \ \left\{ \begin{matrix}   
  maxVal,\ \ curVal > maxVal \\         
  minVal,\ curVal < minVal \\           
  curVal,\ в\ остальных\ случаях \\     
  \end{matrix} \right.\ $$              
  ------------------------------------- --

### Алгоритм функции getPixelLinear

Функция getPixelLinear предназначена для формирования текстурного значения в случае, если значение параметра NMGL_TEXTURE_MIN_FILTER равно NMGL_LINEAR. На вход функции передаются следующие параметры: массивы значений текстурных координат s и t, приведённые с помощью функции wrapCoord; режим обработки границ по оси s (значение параметра NMGL\_ TEXTURE_WRAP_S), режим обработки границ по оси t (значение параметра NMGL\_ TEXTURE_WRAP_T), указатель на текстурный массив (текстуру), количество элементов массива. На выходе формируется массив результирущих текстурных значений. Для каждого элемента входного массива выполняются следующие действия:

6.  Вычислить значения u и v.

+----------------------------+---+
| > $u = \ textureWidth*s$,  |   |
+============================+===+
| $v = \ textureHeight*t$*,* |   |
+----------------------------+---+

где textureWidth и textureHeight -- соответственно ширина и высота переданной в качестве параметра текстуры.

7.  Вычислить значения i~0~, j~0~, i~1~, j~1~, используемые в дальнейшем в качестве индексов текселей (элементов в текстурном массиве).

  $$i_{0} = \ \left\{ \begin{matrix}                                                                                                                     
  \left\lfloor u - \ 1/2 \right\rfloor\ \text{mod}\ 2^{n},\ если\ \text{NMGL}\_\text{TEXTURE}\_\text{WRAP}\_ S\ равно\ \text{NMGL}\_\text{REPEAT}\  \\   
  \left\lfloor u - \ 1/2 \right\rfloor,\ в\ противном\ случае \\                                                                                         
  \end{matrix} \right.\ $$                                                                                                                               
  ------------------------------------------------------------------------------------------------------------------------------------------------------ --
  $$j_{0} = \ \left\{ \begin{matrix}                                                                                                                     
  \left\lfloor v - \ 1/2 \right\rfloor\text{\ mod\ }2^{m},\ если\ NMGL\_ TEXTURE\_ WRAP\_ T\ равно\ NMGL\_ REPEAT\  \\                                   
  \left\lfloor v - \ 1/2 \right\rfloor,\ в\ противном\ случае \\                                                                                         
  \end{matrix} \right.\ $$                                                                                                                               
  $i_{1} = \ \left\{ \begin{matrix}                                                                                                                      
  \left( i_{0} + 1 \right)\text{mod}\ 2^{n},\ если\ \text{NMGL}\_\text{TEXTURE}\_\text{WRAP}\_ S\ равно\ \text{NMGL}\_\text{REPEAT}\  \\                 
  \left\lfloor u - \ 1/2 \right\rfloor,\ в\ противном\ случае \\                                                                                         
  \end{matrix} \right.\ $                                                                                                                                
  $$j_{1} = \ \left\{ \begin{matrix}                                                                                                                     
  \left( j_{0} + 1 \right)\text{\ mod\ }2^{m},\ если\ NMGL\_ TEXTURE\_ WRAP\_ T\ равно\ NMGL\_ REPEAT\  \\                                               
  \left\lfloor v - \ 1/2 \right\rfloor,\ в\ противном\ случае \\                                                                                         
  \end{matrix} \right.\ $$                                                                                                                               

2^n^, 2^m^ -- ширина и высота текстуры соответственно (textureWidth и textureHeight).

8.  Вычислить значения коэффициентов *α* и *β:*

  *α* = frac (*u* -- 1/2)   
  ------------------------- --
  *β* = frac (*v* -- 1/2)   

где frac(x) означает дробную часть *x*.

9.  Получить текстурные значения τ~i0j0~, τ~i1j0~, τ~i0j1~, τ~i1j1~, где *τ~ij\ ~*-- тексель с индексом *(i, j)* в двухмерном текстурном изображении. Если какое либо из значений *τ~ij~* относятся к граничному текселю c i \< ‑b~s~, j \< -b~s~, i ≥w~s~‑b~s~ или j ≥ h~s~‑b~s~ (b~s~ для OpenGL SС равно 0), то вместо неопределенного значения (или значений) *τ~ij\ ~*установить в значение цвета границы, задаваемое значением параметра NMGL_NMGL_TEXTURE_BORDER_COLOR (имеет значение {0,0,0,0}). В противном случае τ~i0j0~, τ~i1j0~, τ~i0j1~, τ~i1j1~ считываются из текстуры с помощью функции getPixelValue.

10. Вычислить итоговое текстурное значение (для двумерной текстуры):

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ --
  $$\tau = \left( 1 - \alpha\  \right)\left( 1 - \beta \right)\tau_{i0j0} + \alpha\left( 1 - \beta \right)\tau_{i1j0} + \ \left( 1 - \alpha\  \right)\beta\tau_{i0j1} + \alpha\beta\tau_{i1j1}$$   
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ --

### Алгоритм функции getPixelNearest

Функция getPixelNearest предназначена для формирования текстурного значения в случае, если значение параметра NMGL_TEXTURE_MIN_FILTER равно NMGL_NEAREST. На вход функции передаются следующие параметры: массив значений текстурных координат s и t, приведённых с помощью функции wrapCoord; режим обработки границ по оси s (значение параметра NMGL\_ TEXTURE_WRAP_S), режим обработки границ по оси t (значение параметра NMGL\_ TEXTURE_WRAP_T), указатель на текстурный массив (текстуру), количество элементов. На выходе формируется массив результирущих текстурных значений. Для каждого элемента входного массива выполняются следующие действия:

4.  Вычислить значения u и v.

+----------------------------+---+
| > $u = \ textureWidth*s$,  |   |
+============================+===+
| $v = \ textureHeight*t$*,* |   |
+----------------------------+---+

где textureWidth и textureHeight -- соответственно ширина и высота переданной в качестве параметра текстуры.

5.  Вычислить значения i и j, используемые в дальнейшем в качестве индексов текселя (элемента в текстурном массиве).

  $i = \ \left\{ \begin{matrix}               
  \left\lfloor u \right\rfloor,\ \ s < 1 \\   
  2^{n} - 1,\ \ s = 1 \\                      
  \end{matrix} \right.\ $,                    
  ------------------------------------------- --
  $j = \ \left\{ \begin{matrix}               
  \left\lfloor v \right\rfloor,\ \ t < 1 \\   
  2^{m} - 1,\ \ t = 1 \\                      
  \end{matrix} \right.\ $,                    

2^n^, 2^m^ -- ширина и высота текстуры соответственно.

6.  Считать итоговое текстурное значение из текстуры -- тексель с индексами i и j -- с помощью функции getPixelValue.

### Алгоритм функции getPixelValue

Функция getPixelValue используется для считывания из текстуры элемента (текселя) с заданными индексами. На вход функции подаются индексы x и y элемента, а также указатель на текстуру. Функция возвращает значение текселя.

6.  Вычислить количество байтов в текселе bytesPix в зависимости от формата текстуры.

7.  Вычислить количество байтов, используемое для дополнения строк в текстуре до заданного значения выравнивания.

  ------------------------------------------------------------------------------------------------- --
  $\text{rPad} = \ \left\{ \begin{matrix}                                                           
  \text{alignment} - w*\text{bytesPix},\ если\ (w*\text{bytesPix})\ \%\ \text{alignment} > \ 0 \\   
  0,\ в\ противном\ случае \\                                                                       
  \end{matrix} \right.\ $,                                                                          
  ------------------------------------------------------------------------------------------------- --

> где w -- ширина текстуры в текселях.

8.  Вычислить ширину строки текстуры в байтах.

  ------------------------------------------------------- --
  $$\text{imgWidt}h\text{Bytes} = \ w*bytesPix + rPad$$   
  ------------------------------------------------------- --

9.  Вычислить позицию текселя в текстуре.

  -------------------------------------------------------------------- --
  $$\text{pixelPos} = \ y*\text{imgWidt}h\text{Bytes} + x*bytesPix$$   
  -------------------------------------------------------------------- --

10. Считать значение текселя по смещению pixelPos в текстурном массиве.

Выводы
------

Алгоритм текстурирования примитивов в соответствии со спецификацией OpenGL SC 1.0.1 задействует большое количество арифметических операций над числами с плавающей точкой и описывает последовательность действий над отдельными пикселями. В связи с этим наиболее эффективным вариантом реализации функций из состава \"Библиотеки графических функций текстурирования\" с использованием особенностей архитектуры векторно-матричного процессорного ядра NMC4 является реализация на процессороном ядре NMC4 с сопроцессором арифметики с плавающей точкой. Использование сопроцессора позволяет увеличить количество одновременно обрабатываемых в пикселей за счёт векторизации вычислений, что увеличивает производительность текстурирования. В конвейере nmOpenGL сопроцессором арифметики с плавающей точкой оборудовано процессорное ядро NMPU0, выполняющее функции геометрических преобразований вершин примитивов, в то время как растеризация и закрашивание пикселей примитивов выполняется на процессорном ядре NMPU1. В рамках работы была выполнена разработка интерфейсных функций текстурирования nmOpenGL, входящих в состав \"Библиотеки графических функций текстурирования\", а также функций текстурирования пикселей, выполняющих непосредственно закрашивание пикселей в процессе текстурирования. Разработка функций выполнена для процессорного ядра NMPU0. Функции текстурирования из состава \"Библиотеки графических функций текстурирования\" являются интерфейсными и выполняют загрузку текстурных изображений в конвейер, а также установку параметров текстурирования. При реализации текстурирования на процессорном ядре NMPU0 при выполнении данных функций отсутствует необходимость передачи данных на процессорное ядро NMPU1. Функции текстурирования пикселей задействуют векторно-матричный сопроцессор арифметики чисел с плавающей точкой, обеспечивая одновременную обработку данных для заданного количества пикселей текстурируемого примитива.

Библиотека сервисных функций
============================

Данный раздел содержит описание функций из состава \"Библиотеки сервисных функций\". Перечень функций представлен в таблице Таблица 59.

Таблица 59 -- Перечень функций

+-------+------------------------------------------------------------------------------+--------------------------------------------------------+
| № п/п | Наименование функции                                                         | Интерфейс функции                                      |
+=======+==============================================================================+========================================================+
| 1.1   | Функция переупаковки вершин                                                  | int vertexPrimitiveRepack(                             |
|       |                                                                              |                                                        |
|       |                                                                              | const v4nm32f \*srcVertex,                             |
|       |                                                                              |                                                        |
|       |                                                                              | const v4nm32f \*srcColor,                              |
|       |                                                                              |                                                        |
|       |                                                                              | nm32f \*dstVertex,                                     |
|       |                                                                              |                                                        |
|       |                                                                              | v4nm32f \*dstColor,                                    |
|       |                                                                              |                                                        |
|       |                                                                              | int mode,                                              |
|       |                                                                              |                                                        |
|       |                                                                              | int vertCount);                                        |
+-------+------------------------------------------------------------------------------+--------------------------------------------------------+
| 1.2   | Функция конвертации цветового представления BGRA (32-32-32-32) в BGR (5-6-5) | void convertABGR32_RGB565(                             |
|       |                                                                              |                                                        |
|       |                                                                              | const ABGR32 \*srcArray,                               |
|       |                                                                              |                                                        |
|       |                                                                              | RGB565 \*dstArray,                                     |
|       |                                                                              |                                                        |
|       |                                                                              | int count);                                            |
+-------+------------------------------------------------------------------------------+--------------------------------------------------------+
| 1.3   | Функция конвертации цветового представления RGB (5-6-5) в RGB (8-8-8-8)      | void convertRGB565_RGB8888(                            |
|       |                                                                              |                                                        |
|       |                                                                              | const RGB565 \*srcArray,                               |
|       |                                                                              |                                                        |
|       |                                                                              | RGB8888 \*dstArray,                                    |
|       |                                                                              |                                                        |
|       |                                                                              | int count);                                            |
+-------+------------------------------------------------------------------------------+--------------------------------------------------------+
| 1.4   | Функция триангуляции                                                         | int triangulate(                                       |
|       |                                                                              |                                                        |
|       |                                                                              | const nm32f \*srcVertex,                               |
|       |                                                                              |                                                        |
|       |                                                                              | const v4nm32f \*srcColor,                              |
|       |                                                                              |                                                        |
|       |                                                                              | int srcCount, int maxWidth,                            |
|       |                                                                              |                                                        |
|       |                                                                              | int maxHeight,                                         |
|       |                                                                              |                                                        |
|       |                                                                              | int maxDstSize,                                        |
|       |                                                                              |                                                        |
|       |                                                                              | nm32f \*dstVertex,                                     |
|       |                                                                              |                                                        |
|       |                                                                              | v4nm32f \*dstColor,                                    |
|       |                                                                              |                                                        |
|       |                                                                              | int \*srcTreatedCount);                                |
+-------+------------------------------------------------------------------------------+--------------------------------------------------------+
| 1.5   | Функция принадлежности объему                                                | void nmppsCmpGteLteMirrorV_32f(const nm32f \*srcArray, |
|       |                                                                              |                                                        |
|       |                                                                              | const nm32f \*wArray,                                  |
|       |                                                                              |                                                        |
|       |                                                                              | nm1\* evenFlags,                                       |
|       |                                                                              |                                                        |
|       |                                                                              | nm1\* oddFlags,                                        |
|       |                                                                              |                                                        |
|       |                                                                              | int size);                                             |
+-------+------------------------------------------------------------------------------+--------------------------------------------------------+

Функциональные требования
-------------------------

### Функция переупаковки вершин

#### Прототип функции

int vertexPrimitiveRepack(const v4nm32f \*srcVertex, const v4nm32f \*srcColor, nm32f \*dstVertex, v4nm32f \*dstColor, int mode, int vertCount);

#### Назначение

Требуется в зависимости от типа примитива mode (GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN) преобразовать массив вершин в массив треугольников с соблюдением порядка обхода вершин (по часовой стрелке или против). Результирующие треугольники должны быть представлены в виде 13 массивов, разбитых на две группы. Первая группа представляет собой 12 массивов, которые должны быть расположены друг за другом. Вторая группа представляет собой набор 4-мерных векторов цвета.

#### Входные данные

srcVertex -- указатель на массив координат вершин, представляющий двумерный массив, в котором число столбцов равно размерности вектора вершины (4 координаты), а число рядов соответствует количеству вершин (см. рисунок Рисунок 8).

![D:\\GIT\\nmc_doc\\others\\images\\fig_1a.png](media/image9.png){width="4.0375in" height="0.9055555555555556in"}

Рисунок 8 - Представление массива srcVertex (x, y, z, w -- координаты вершин)

srcColor -- указатель на массив соответствующих цветов вершин, представляющий собой набор 4-мерных векторов (см. рисунок Рисунок 9).

![D:\\GIT\\nmc_doc\\others\\images\\fig_1b.png](media/image10.png){width="4.009722222222222in" height="0.9055555555555556in"}

Рисунок 9 - Представление массива srcColor (r, g, b, a -- цветовые компоненты вершин)

vertCount - число переданных вершин.

mode -- тип примитивов, который будет использован для создания треугольников из вершин, определяемых указателем srcVertex. Возможные значения: GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN.

#### Выходные данные

dstVertex -- указатель на первую группу массивов, которая представляет собой 12 массивов, лежащих друг за другом. Каждый массив содержит n элементов. Значение n определяется числом переданных вершин vertCount и типом треугольных полигонов mode. Если тип треугольных полигонов соответствует GL_TRIANGLE_STRIP или GL_TRIANGLE_FAN, то размер массива n =vertCount-2. Если тип треугольных полигонов соответствует GL_TRIANGLES, то размер массива n=vertCount/3. Каждый из 12 массивов dstVertex хранит значения одной из координат одной из вершин треугольника (x~A~, y~A~, z~A~, w~A~, x~B~, y~B~, z~B~, w~B~, x~C~, y~C~, z~C~, и w~C~ где A, B, C -- вершины треугольных полигонов) (см. рисунок Рисунок 10).

![D:\\GIT\\nmc\\doc\\others\\images\\fig_2a.png](media/image11.png){width="1.4895833333333333in" height="2.7083333333333335in"}

Рисунок 10 - Представление массива dstVertex (A, B, С - вершины треугольных полигонов, n -- число получившихся полигонов)

dstColor -- указатель на выходной массив цветов примитивов (см. рисунок Рисунок 11). Массив цветов представляет собой набор 4-мерных векторов цвета, расположенных в соответствии с порядком вершин в dstVertex.

![D:\\GIT\\nmc\\doc\\others\\images\\fig_2b.png](media/image12.png){width="1.84375in" height="2.6145833333333335in"}

Рисунок 11 - Представление массива dstColor (r, g, b, a -- цветовые компоненты полигонов, n -- число получившихся полигонов)

#### Возвращаемое значение

Размер (n) каждого массива в dstVertex.

### Функция конвертации цветового представления BGRA (32-32-32-32) в BGR (5-6-5)

#### Прототип функции

void convertABGR32_RGB565(const ABGR32 \*srcArray, RGB565 \*dstArray, int count);

#### Назначение

Требуется написать функцию преобразования значений цветов из формата ABGR32 в формат RGB565 (R - красная составляющая цвета, G -- зеленая, B -- синяя, A - прозрачность):

> ABGR32 -- представляет собой 4-мерный вектор, в котором каждый цвет находится в отдельном 32-разрядном числе {R, G, B, A} (R -- нулевой элемент вектора); каждый компонент цвета (R, G, B, A) хранится в младшем байте 32-битного слова. При конвертации из компонента извлекаются младшие 5/6/5 бит, то есть: R5 = R32\[4:0\], G6 = G32\[5:0\], B5 = B32\[4:0\].
>
> RGB565 -- представляет собой 3-мерный вектор {R (5 старших бит), G (6 бит), B (5 младших бит)}.

#### Входные данные

srcArray -- указатель на входной массив значений цветов.

count -- число переданных векторов.

#### Выходные данные

dstArray -- указатель на преобразованный массив значений цветов.

#### Возвращаемое значение

> Отсутствует.

### Функция конвертации цветового представления RGB (5-6-5) в RGB (8-8-8-8)

#### Прототип функции

void convertRGB565_RGB8888(const RGB565 \*srcArray, RGB8888 \*dstArray, int count);

#### Назначение

Требуется написать функцию преобразования значений цветов из формата RGB565 в формат RGB8888 (R - красная составляющая цвета, G -- зеленая, B -- синяя):

> RGB565 -- представляет собой 3-мерный вектор {B (5 младших бит), G (6 бит), R (5 старших бит)};
>
> RGB8888 -- представляет собой 4-мерный вектор, где каждый компонент занимает 8 бит (B -- младшие 8 бит, G -- 8 бит, R -- 8 бит, старшие 8 бит -- не используются)**.**

#### Входные данные

srcArray -- указатель на входной массив значений цветов.

count -- число переданных векторов.

#### Выходные данные

dstArray -- указатель на результирующий массив значений цветов.

#### Возвращаемое значение

Отсутствует.

### Функция триангуляции

#### Прототип функции

int triangulate(const nm32f \*srcVertex, const v4nm32f \*srcColor, int srcCount, int maxWidth, int maxHeight, int maxDstSize , nm32f \*dstVertex, v4nm32f \*dstColor, int \*srcTreatedCount);

#### Назначение

Данная функция должна выполнять деление треугольников, переданных во входном массиве, на треугольники меньшего размера. Результатом деления является выходной массив треугольников, размеры которых по x и y не превышают заданных значений maxWidth и maxHeight.

Каждый треугольник входного массива делится, пока размеры каждого из составляющих его треугольников по осям x и y превышают значения maxWidth и maxHeight соответственно. Далее осуществляется переход к следующему треугольнику входного массива. Деление начинается с первого треугольника входного массива. Если размеры очередного треугольника входного массива не превышают заданных значений, его деление не требуется, он считается обработанным и помещается в выходной массив. Деление должно сопровождаться соответствующим изменением координат z и значений цветов.

В выходном массиве хранятся треугольники заданного размера: треугольники, получившиеся в результате деления большого треугольника, а также те, которые прошли проверку на размер сразу и не требовали деления. Число треугольников в выходном массиве не должно превышать значения maxDstSize. Если на этапе деления треугольника из входного массива происходит превышение максимально допустимого значения maxDstSize, деление этого треугольника прекращается (уже полученные составляющие в выходной массив не помещаются). Если выходной массив уже заполнен и обработка очередного треугольника входного массива приведёт к превышению максимально допустимого значения maxDstSize, работа функции также завершается. В переменную srcTreatedCount возвращается число полностью обработанных треугольников входного массива.

#### Входные данные

srcVertex-- указатель на входной массив треугольников. Массив представляет собой двумерный массив из 9 рядов, в каждом из которых лежит координата одной из вершин треугольного полигона (Ax, Ay, Az, Bx, By, Bz, Cx, Cy, Cz -- где A, B и С -- вершины полученных треугольных полигонов) (см. рисунок Рисунок 12).

![D:\\GIT\\nmc\\doc\\others\\images\\fig_3.png](media/image13.png){width="1.6458333333333333in" height="2.0625in"}

Рисунок 12 - Представление массива srcVertex (A, B, С - вершины треугольных полигонов, count -- число полигонов)

srcColor -- указатель на входной массив цветов полигонов, представляющий собой набор 4-мерных векторов (R,G,B,A) (см. рисунок Рисунок 13).

![D:\\GIT\\nmc\\doc\\others\\images\\fig_4.png](media/image14.png){width="2.84375in" height="2.6145833333333335in"}

Рисунок 13 - Представление массива srcColor (R,G,B,A -- цветовые компоненты полигонов, count -- число полигонов)

srcCount - количество входных треугольных полигонов и число столбцов массива srcVertex.

maxWidth - максимальное значение ширины выходных треугольников.

maxHeight - максимальное значение высоты выходных треугольников.

maxDstSize -- максимально возможное число треугольников в выходном массиве.

#### Выходные данные

dstVertex -- указатель на выходной массив треугольников, размер которых не превышает maxWidth по оси x и maxHeight по оси y. Так же, как и входной массив, dstVertex представляет собой двумерный массив из 9 рядов, в каждом из которых лежит координата одной из вершин треугольного полигона (см. рисунок Рисунок 14). Размер каждого массива равен maxDstSize.

![D:\\GIT\\nmc\\doc\\others\\images\\fig_5.png](media/image15.png){width="1.9895833333333333in" height="2.0625in"}

Рисунок 14 - Представление массива dstVertex (A, B, С - вершины треугольных полигонов, maxDstSize -- число полигонов)

dstColor -- указатель на выходной массив цветов примитивов (см. рисунок Рисунок 15). Массив цветов представляет собой набор 4-мерных векторов цвета, расположенных в соответствии с порядком вершин в dstVertex.

![D:\\GIT\\nmc\\doc\\others\\images\\fig_6.png](media/image16.png){width="4.21875in" height="2.6145833333333335in"}

Рисунок 15 - Представление массива dstColor (R, G, B, A -- цветовые компоненты полигонов, maxDstSize -- число полигонов)

srcTreatedCount - число полностью обработанных треугольников входного массива.

#### Возвращаемое значение

Количество треугольных полигонов в выходном массиве dstVertex.

### Функция принадлежности объёму 

Необходимо разработать функцию проверки элементов массива на принадлежность диапазонам, определяемым другим массивом (на векторном ядре).

#### Прототип функции:

void nmppsCmpGteLteMirrorV_32f(const nm32f \*srcArray, const nm32f \*wArray, nm1\* evenFlags, nm1\* oddFlags, int size);

#### Назначение

Требуется написать функцию, реализующую следующую операцию:

> evenFlags\[i\]=$\left\{ \begin{matrix}
> 1,\ \ если\  - w\left\lbrack 2*i \right\rbrack \leq x\left\lbrack 2*i \right\rbrack \leq w\left\lbrack 2*i \right\rbrack \\
> 0 - \ \ в\ противном\ случае \\
> \end{matrix} \right.\ ,$
>
> oddFlags\[i\]=$\left\{ \begin{matrix}
> 1,\ \ если\  - w\left\lbrack 2*i + 1 \right\rbrack \leq x\left\lbrack 2*i + 1 \right\rbrack \leq w\left\lbrack 2*i + 1 \right\rbrack \\
> 0 - \ \ в\ противном\ случае \\
> \end{matrix} \right.\ ,$
>
> где *0≤ i \< size/2.*

#### Входные данные

srcArray -- указатель на входной массив значений x.

wArray -- указатель на массив значений w, задающих диапазон {‑w, w}.

size - количество проверяемых значений (размер srcArray и wArray), принимает четное значение.

#### Выходные данные

evenFlags -- указатель на выходной битовый массив флагов с результатами проверки принадлежности диапазону для четных элементов (1 -- значение принадлежит диапазону, 0 - нет).

oddFlags -- указатель на выходной битовый массив флагов с результатами проверки принадлежности диапазону для нечетных элементов(1 -- значение принадлежит диапазону, 0 - нет).

Если size не кратен 32, то завершающие биты в массивах до границы 32-р слов дополняются нулями.

#### Возвращаемое значение

Отсутствует.

Алгоритмы функций 
-----------------

### Функция переупаковки вершин

Функция переупаковки вершин работает в соответствии со следующим алгоритмом:

1.  В зависимоcти от типа примитивов mode и количества вершин vertCount во входном массиве определить количество треугольных полигонов trCount в выходном массиве dstVertex:

    1.  если mode = GL_TRIANGLES, то trCount = vertCount/3;

    2.  если mode = GL_TRIANGLE_STRIP, то trCount = vertCount -- 2;

    3.  если mode = GL_TRIANGLE_FAN, то trCount = vertCount -- 2;

2.  Для каждого треугольника i (0 ≤ i \< trCount) в зависимости от типа примитива mode вычислить координаты составляющих его вершин a, b и с по следующим правилам:

    1.  если mode = GL_TRIANGLES, то:

> a = srcVertex\[3\*i\],
>
> b = srcVertex\[3\*i + 1\],
>
> c = srcVertex\[3\*i + 2\],

2.  если mode = GL_TRIANGLE_STRIP, то:

> для чётных i:
>
> a = srcVertex\[i\], b = srcVertex\[i + 1\], c = srcVertex\[i + 2\];
>
> для нечётных i:
>
> a = srcVertex\[i + 1\], b = srcVertex\[i\], c = srcVertex\[i + 2\].

3.  если mode = GL_TRIANGLE_FAN, то:

> a = srcVertex\[0\],
>
> b = srcVertex\[i + 1\],
>
> c = srcVertex\[i + 2\].

3.  Аналогично пункту 2 вычислить цвета вершин каждого треугольника.

4.  Сформировать выходные массивы координат и цветов.

### Функция конвертации цветового представления BGRA (32-32-32-32) в BGR (5-6-5)

Функция конвертации цветового представления BGRA (32-32-32-32) в BGR (5-6-5) работает в соответствии со следующим алгоритмом:

1.  Для каждого значения цвета во входном массиве выполнить преобразование в соответствии со следующими правилами:

> rgb565.r = rgba32.r & 0x1F,
>
> rgb565.g = rgba32.g & 0x3F,
>
> rgb565.b = rgba32.b & 0x1F,
>
> где r -- красная компонента соответствующего цветового представления,
>
> g -- зелёная компонента соответствующего цветового представления,
>
> b -- синяя компонента соответствующего цветового представления.
>
> Компонента rgba32.a не используется в итоговом представлении rgb565 отсутствует, поэтому её преобразование не требуется.

2.  Полученное значение цветового представления в формате rgb565 сохранить в выходном массиве.

### Функция конвертации цветового представления RGB (5‑6‑5) в RGB (8‑8‑8‑8)

Функция конвертации цветового представления RGB (5‑6‑5) в RGB (8‑8‑8‑8) работает в соответствии со следующим алгоритмом:

1.  Для очередного значения цвета во входном массиве выполнить следующие действия:

    1.  преобразовать значение в формат RGB (5-6-5)в соответствии со следующими правилами:

> rgb8888.r = (rgb565.r \<\< 3) \| (rgb565.r \>\> 2),
>
> rgb8888.g = (rgb565.g \<\< 2) \| (rgb565.r \>\> 4),
>
> rgb8888.b = (rgb565.b \<\< 3) \| (rgb565.b \>\> 2),
>
> где r -- красная компонента соответствующего цветового представления,
>
> g -- зелёная компонента соответствующего цветового представления,
>
> b -- синяя компонента соответствующего цветового представления,
>
> старшие 8 бит в представлении rgb8888 установить равными 0.

2.  полученное значение цветового представления в формате rgb8888 сохранить в выходном массиве.

```{=html}
<!-- -->
```
2.  Перейти к следующему элементу во входном массиве.

### Функция триангуляции

Разбиение треугольников из входного массива осуществляется последовательно. Дополнительная память для хранения промежуточных результатов не выделяется. Для этого используется память выходных массивов, организованная в виде стека. В процессе разбиения промежуточные результаты хранятся в одном конце стека, а уже разбитые треугольники заданного размера -- в другом. Схематично данный процесс представлен на рисунке Рисунок 16.

Рисунок 16 - Использования памяти выходных массивов для хранения промежуточных результатов разбиения

Разбиение треугольника осуществляется в соответствии со следующим алгоритмом:

1.  Инициализировать стек для хранения вершин в памяти выходного массива вершин.

2.  Инициализировать стек для хранения цветов в памяти выходного массива цветов.

3.  Если обработаны все входные треугольники, перейти к пункту 8.

4.  Извлечь очередной треугольник из входного массива:

    1.  Извлечь вершины треугольника.

    2.  Извлечь цвета вершин треугольника.

5.  Выполнить разбиение текущего треугольника на треугольники меньшего размера с помощью функции triangulateOneTriangle:

    1.  Проверить наличие места в выходном массиве для хранения по крайней мере одного треугольника. Если свободное место отсутствует (разбиение треугольника невозможно), завершить выполнение функции и перейти к пункту 5.

    2.  Поместить треугольник в конец стека.

    3.  Проверить наличие треугольников в конце стека.

    4.  Если в конце стека треугольники отсутствуют, то исходный треугольник полностью разбит, перейти к пункту 5.11.

    5.  Проверить (по флагу переполнения) наличие свободного места в выходном массиве.

    6.  Если места в выходном массиве недостаточно (флаг переполнения установлен в 1), разбиение треугольника считается неуспешным, перейти к пункту 5.11.

    7.  Извлечь очередной треугольник из конца стека.

    8.  Проверить, необходимо ли разбиение треугольника, и разбить его с помощью функции checkAndSplitLargestEdge.

        1.  Найти самую длинную сторону треугольника.

        2.  Если самая длинная сторона треугольника превышает максимально допустимый размер, разбить треугольник на две части путём деления самой длинной стороны пополам.

        3.  Рассчитать цвет новой вершины как среднее арифметическое цветов вершин, образующих самую длинную сторону.

    9.  Если треугольник был разбит:

        1.  проверить, есть ли место в выходном массиве для хранения двух новых треугольников;

        2.  если свободное место есть, поместить два получившихся треугольника в стек, иначе -- установить флаг переполнения выходного массива;

        3.  перейти к пункту 5.3.

    10. Если треугольник не разбит (его деление не требуется):

        1.  Поместить треугольник в выходной массив.

        2.  Перейти к пункту 5.3.

    11. Если в конце стека треугольники отсутствуют (треугольник полностью разбит), вернуть текущее количество треугольников в выходном массиве, перейти к пункту 6.

    12. Если в выходном массиве недостаточно места, деление треугольника выполнено неуспешно, перейти к пункту 6.

6.  Если разбиение текущего треугольника выполнено неуспешно, завершить обработку входного массива, перейти к пункту 8.

7.  Если разбиение текущего треугольника выполнено успешно, сохранить количество треугольников в выходном массиве, перейти к пункту 3.

8.  Вернуть число полностью обработанных треугольников входного массива.

9.  Вернуть количество треугольников в выходном массиве.

### Функция принадлежности объёму

Функция принадлежности объёму работает в соответствии со следующим алгоритмом:

1.  Инициализировать выходные массивы флагов нулевыми значениями.

2.  Для каждого выходного массива битовых флагов вычислить значение флага i по в соответствии со следующими правилами:

> evenFlags\[i\] =$\ \left\{ \begin{matrix}
> 1,\ \ если\  - w\left\lbrack 2*i \right\rbrack \leq x\left\lbrack 2*i \right\rbrack \leq w\left\lbrack 2*i \right\rbrack \\
> 0 - \ \ в\ противном\ случае \\
> \end{matrix} \right.\ ,$
>
> oddFlags\[i\] =$\ \left\{ \begin{matrix}
> 1,\ \ если\  - w\left\lbrack 2*i + 1 \right\rbrack \leq x\left\lbrack 2*i + 1 \right\rbrack \leq w\left\lbrack 2*i + 1 \right\rbrack \\
> 0 - \ \ в\ противном\ случае \\
> \end{matrix} \right.\ ,$
>
> где *0 ≤ i \< size/2.*

